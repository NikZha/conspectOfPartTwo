<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blob</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#blob">Blob</a></h2>
        <ul>
            <li><a href="#url">Blob как URL</a></li>
            <li><a href="#base64">Blob to base64</a></li>
            <li><a href="#pick">Изображение в Blob</a></li>
            <li><a href="#arraybufer">Из Blob в ArrayBuffer</a></li>
            <li><a href="#total">Итого</a></li>
        </ul>
    </div>
    <div class="topic" id="blob">
        <h2><a href="https://learn.javascript.ru/blob">Blob</a></h2>
        <p>Собственно класс который отвечает за передачу бинарных данных:</p>
        <pre><code class="language-js">
new Blob(blobParts, options);        
    </code></pre>
        <ul>
            <li><code>blobParts</code> – массив значений Blob/BufferSource/String.</li>
            <li><code>options</code> – необязательный объект с дополнительными настройками:</li>
            <ul>
                <li><code>type</code> – тип объекта, обычно MIME-тип, например. image/png,</li>
                <li><code>endings</code> – если указан, то окончания строк создаваемого Blob будут изменены в
                    соответствии с текущей операционной системой (\r\n или \n). По умолчанию "transparent" (ничего не
                    делать), но также может быть "native" (изменять). </li>
            </ul>
        </ul>
        <p>Например:</p>
        <pre><code class="language-js">
// создадим Blob из строки
let blob = new Blob(["<html>…</html>"], {type: 'text/html'});
// создадим Blob из типизированного массива и строк
let hello = new Uint8Array([72, 101, 108, 108, 111]); // "hello" в бинарной форме

let blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});        
    </code></pre>
        <blockquote>
            <h4>Blob не изменяем (immutable)</h4>
            <p>Мы не можем изменять данные напрямую в Blob, но мы можем делать срезы и создавать новый Blob на их
                основе, объединять несколько объектов в новый и так далее.</p>
        </blockquote>
    </div>
    <div class="topic" id="url">
        <h3>Blob как URL</h3>
        <p><code>Blob</code> может быть использован, как ссылка <code>a</code> или изображение <code>img</code>:</p>
        <pre><code class="language-js">
&lt;!-- download атрибут указывает браузеру делать загрузку вместо навигации --&gt;
&lt;a download="hello.txt" href='#' id="link">Загрузить&lt;/a>

&lt;script>
let blob = new Blob(["Hello, world!"], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);
&lt;/script>            
        </code></pre>
        <!-- download атрибут указывает браузеру делать загрузку вместо навигации -->
        <a download="hello.txt" href='#' id="link">Загрузить</a>

        <script>
            let blob = new Blob(["Hello, world!"], { type: 'text/plain' });

            link.href = URL.createObjectURL(blob);
        </script>
        <p>Сгенеренный урл будет вида: <code>blob:*</code>.</p>
        <p>Так же можно запускать загрузку при помощи <code>link.click()</code> автоматически. Удалить линк, чтобы не
            засорять память можно при помощи: <code>URL.revokeObjectURL(url)</code>.</p>
    </div>
    <div class="topic" id="base64">
        <h3>Blob to base64</h3>
        <p>Альтернатива <code>URL.createObjectURL</code> – конвертация Blob-объекта в строку с кодировкой base64.
        </p>
        <p>Эта кодировка представляет двоичные данные в виде строки с безопасными для чтения символами в ASCII-кодах от
            0 до 64. И что более важно – мы можем использовать эту кодировку для «data-urls».</p>
        <p>data url имеет форму <code>data:[&lt;mediatype>][;base64],&lt;data></code>. Мы можем использовать такой url
            где угодно наряду с «обычным» url. Например:</p>
        <pre><code class="language-js">
&lt;img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">    
</code></pre>
        <img
            src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">
        <script>
            function expl1(params) {
                let link = document.createElement('a');
                link.download = 'hello.txt';

                let blob1 = new Blob(['Hello, world!'], { type: 'text/plain' });

                let reader = new FileReader();
                reader.readAsDataURL(blob1); // конвертирует Blob в base64 и вызывает onload


                link.href = reader.result; // url с данными
                link.click();

            }   
        </script>
        <p>Самое главно, что можно трансформировать <code>blob</code> в <code>base64</code> используя встроенный в
            браузер объект типа <code>FileReader</code>. Например:</p>
        <pre><input type="button" value="Тест blobToBase64" onclick="expl1()"><code class="language-js">
let link = document.createElement('a');
link.download = 'hello.txt';

let blob1 = new Blob(['Hello, world!'], { type: 'text/plain' });

let reader = new FileReader();
reader.readAsDataURL(blob1); // конвертирует Blob в base64 и вызывает onload


link.href = reader.result; // url с данными
link.click();            
        </code></pre>
        <p>
            Сравнение <code>URL.createObjectURL(blob)</code> и <code>Blob to data url</code>:
        </p>
        <table>
            <thead>
                <tr>
                    <th>URL.createObjectURL(blob)</th>
                    <th>Blob to data url</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <ul>
                            <li>Нужно отзывать объект для освобождения памяти.</li>
                            <li>Прямой доступ к Blob, без «кодирования/декодирования».</li>
                        </ul>
                    </td>
                    <td>
                        <ul>
                            <li>Нет необходимости что-либо отзывать.</li>
                            <li>Потеря производительности и памяти при декодировании больших Blob-объектов.</li>
                        </ul>
                    </td>
                </tr>
            </tbody>
        </table>
        <p>Таким образом <code>URL.createObjectURL(blob)</code> обычно быстрее и позовляет контролировать освобождение
            памяти.</p>
    </div>
    <div class="topic" id="pick">
        <h3>Изображение в Blob</h3>
        <p>Операции перевода изображения в <code>Blob</code> осуществлятся за счет <code>&lt;canvas&gt;</code>
            использованием метода <code>.toBlob(callback, format, quality)</code>.</p>
        <p>Как пример:</p>
        <pre><code class="language-js">
// берём любое изображение
let img = document.querySelector('img');

// создаём <canvas> того же размера
let canvas = document.createElement('canvas');
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

let context = canvas.getContext('2d');

// копируем изображение в  canvas (метод позволяет вырезать часть изображения)
context.drawImage(img, 0, 0);
// мы можем вращать изображение при помощи context.rotate() и делать множество других преобразований

// toBlob является асинхронной операцией, для которой callback-функция вызывается при завершении
canvas.toBlob(function(blob) {
  // после того, как Blob создан, загружаем его
  let link = document.createElement('a');
  link.download = 'example.png';

  link.href = URL.createObjectURL(blob);
  link.click();

  // удаляем внутреннюю ссылку на Blob, что позволит браузеру очистить память
  URL.revokeObjectURL(link.href);
}, 'image/png');                
            </code></pre>
    </div>
    <div class="topic" id="arraybufer">
        <h3>Из Blob в ArrayBuffer</h3>
        <p>
            <code>FileReader</code> позволяет перегнать из блоба в <code>ArrayBuffer</code>, почему-то работает только в
            таком виде:
        <pre><input type="button" value="Из Blob в ArrayBuffer" onclick="expl2()"><code class="language-js">
function expl2(params) {
    let fileReader = new FileReader();
    let blob = new Blob(['Hello, world!'], { type: 'text/plain' });
    fileReader.readAsArrayBuffer(blob);
    fileReader.onload = function (event) {
    let arrayBuffer = fileReader.result;
    alert(arrayBuffer)
    };
    
}                
            </code></pre>
        </p>
        <script>
            function expl2(params) {
                let fileReader = new FileReader();
                let blob = new Blob(['Hello, world!'], { type: 'text/plain' });
                fileReader.readAsArrayBuffer(blob);
                fileReader.onload = function (event) {
                    let arrayBuffer = fileReader.result;
                    alert(arrayBuffer)
                };

            }
        </script>

    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>В то время как ArrayBuffer, Uint8Array и другие BufferSource являются «бинарными данными», Blob представляет
            собой «бинарные данные с типом».</p>

        <p>Это делает Blob удобным для операций загрузки/выгрузки данных, которые так часто используются в браузере.</p>

        <p>Методы, которые выполняют сетевые запросы, такие как XMLHttpRequest, fetch и подобные, могут изначально
            работать с Blob так же, как и с другими объектами, представляющими двоичные данные.</p>

        <p>Мы можем легко конвертировать Blob в низкоуровневые бинарные типы данных и обратно: </p>
        <ul>
            <li>Мы можем создать Blob из типизированного массива, используя конструктор new Blob(...).</li>
            <li>Мы можем обратно создать ArrayBuffer из Blob, используя FileReader, а затем создать его представление
                для низкоуровневых операций. </li>
        </ul>
    </div>



</body>

</html>