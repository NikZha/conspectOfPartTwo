<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fetch: ход загрузки</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#progress">Fetch: ход загрузки</a></h2>
        <h2><a href="#abort">Fetch: прерывание запроса</a></h2>
    </div>
    <div class="topic" id="progress">
        <h2><a href="https://learn.javascript.ru/fetch-progress">Fetch: ход загрузки</a></h2>
        <p>Не понимаю зачем этот топик, но пусть будет.</p>
        <p><code>response.body</code> - позволяет отслеживать сколько и чего загрузилось в ответ. В отличии от
            <code>.json()</code> позволяет несколько раз дёргать это свойство.
        </p>
        <p>Упрощённый код для иллюстрации:</p>
        <pre><code class="language-js">
// вместо response.json() и других методов
const reader = response.body.getReader();

// бесконечный цикл, пока идёт загрузка
while(true) {
  // done становится true в последнем фрагменте
  // value - Uint8Array из байтов каждого фрагмента
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Получено ${value.length} байт`)
}                
            </code></pre>
        <p>Рабочий код для иллюстрации:</p>
        <input type="button" value="Тест кода из примера" onclick="expl1()">
        <pre><code class="language-js">
// Шаг 1: начинаем загрузку fetch, получаем поток для чтения
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Шаг 2: получаем длину содержимого ответа
const contentLength = +response.headers.get('Content-Length');

// Шаг 3: считываем данные:
let receivedLength = 0; // количество байт, полученных на данный момент
let chunks = []; // массив полученных двоичных фрагментов (составляющих тело ответа)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Получено ${receivedLength} из ${contentLength}`)
}

// Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Шаг 5: декодируем Uint8Array обратно в строку
let result = new TextDecoder("utf-8").decode(chunksAll);

// Готово!
let commits = JSON.parse(result);
alert(commits[0].author.login);                
            </code></pre>
        <p>Для полученя блоба вмиесто строки нужно вместо 4 и 5 шага:</p>
        <pre><code class="language-js">
let blob = new Blob(chunks);                
            </code></pre>
        <script>
            async function expl1() {
                // Шаг 1: начинаем загрузку fetch, получаем поток для чтения
                let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');

                const reader = response.body.getReader();

                // Шаг 2: получаем длину содержимого ответа
                const contentLength = +response.headers.get('Content-Length');

                // Шаг 3: считываем данные:
                let receivedLength = 0; // количество байт, полученных на данный момент
                let chunks = []; // массив полученных двоичных фрагментов (составляющих тело ответа)
                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    chunks.push(value);
                    receivedLength += value.length;

                    console.log(`Получено ${receivedLength} из ${contentLength}`)
                }

                // Шаг 4: соединим фрагменты в общий типизированный массив Uint8Array
                let chunksAll = new Uint8Array(receivedLength); // (4.1)
                let position = 0;
                for (let chunk of chunks) {
                    chunksAll.set(chunk, position); // (4.2)
                    position += chunk.length;
                }

                // Шаг 5: декодируем Uint8Array обратно в строку
                let result = new TextDecoder("utf-8").decode(chunksAll);

                // Готово!
                let commits = JSON.parse(result);
                alert(commits[0].author.login);
            }                
        </script>
    </div>
    <div class="topic" id="abort">
        <h2><a href="https://learn.javascript.ru/fetch-abort">Fetch: прерывание запроса</a></h2>
        <p>Отмена загрузки <code>fetch</code> происходит при помощи специально класса:</p>
        <pre><code class="language-js">
let controller = new AbortController();            
        </code></pre>
        <p>Суть которого в приёме сигнала при помощи метода <code>.abort()</code> и установлении свойства
            <code>.aborted</code> в <code>true</code>. Без <code>fetch</code> это можно продемонстрировать при помощи:
        </p>
        <script>
            function expl2() {
                let controller = new AbortController();
                let signal = controller.signal;

                // срабатывает при вызове controller.abort()
                signal.addEventListener('abort', () => alert("отмена!"));

                controller.abort(); // отмена!

                alert(signal.aborted); // true
            }
        </script>
        <pre><input type="button" value="Тест сигнала отмены" onclick="expl2()"><code class="lang">
let controller = new AbortController();
let signal = controller.signal;

// срабатывает при вызове controller.abort()
signal.addEventListener('abort', () => alert("отмена!"));

controller.abort(); // отмена!

alert(signal.aborted); // true            
        </code></pre>
        <p>Далее объект этого класса <code>AbortController</code> встраивается своим свойством в вызов функции
            <code>fetch</code>:
        </p>
        <pre><code class="lang">
let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});            
        </code></pre>

        <p>И теперь при вызове:</p>
        <pre><code class="language-js">
controller.abort();    
</code></pre>
        <p><code>fetch</code> получает сигнал и останавливает загрузку/отправку. Детально это можно показать на примере:
        </p>
        <input type="button" value="Тест прерывания fetch" onclick="expl3()">
        <script>
            async function expl3() {
                // прервать через 1 секунду
                let controller = new AbortController();
                setTimeout(() => controller.abort(), 1);

                try {
                    let response = await fetch('../index.html', {
                        signal: controller.signal
                    });
                } catch (err) {
                    if (err.name == 'AbortError') { // обработать ошибку от вызова abort()
                        alert("Прервано!");
                    } else {
                        throw err;
                    }
                }
            }
        </script>
        <pre><code class="language-js">
// прервать через 1 миллисекунду
let controller = new AbortController();
setTimeout(() => controller.abort(), 1);

try {
  let response = await fetch('../index.html', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // обработать ошибку от вызова abort()
    alert("Прервано!");
  } else {
    throw err;
  }
} 
</code></pre>
        <p>Тут надо заметить, что браузер запрещает кроссайтовую загрузку и использовать в качестве <code>url</code>
            к примеру <code>ya.ru</code> не удаётся.</p>
        <p>Так же этот класс <code>AbortController</code> позволяет отменять несколько вызовов одновременно:</p>
        <pre><code class="language-js">
let urls = [...]; // список URL для параллельных fetch

let controller = new AbortController();

let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// если откуда-то вызвать controller.abort(),
// то это прервёт все вызовы fetch        
       </code></pre>
        <p>И так же использовать для остановки других ассинхронных задач:</p>
        <pre><code class="language-js">
let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => { // наша задача
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url => fetch(url, { // запросы fetch
  signal: controller.signal
}));

// ожидать выполнения нашей задачи и всех запросов
let results = await Promise.all([...fetchJobs, ourJob]);

// вызов откуда-нибудь ещё:
// controller.abort() прервёт все вызовы fetch и наши задачи        
       </code></pre>
        <p>Таким образом <code>AbortController</code> это универсальный объект для отмены асинхронных задач, в
            <code>fetch</code> встроена интеграция с ним.
        </p>
    </div>
</body>

</html>