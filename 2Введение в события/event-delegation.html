<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Делегирование событий</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body>
  <div class="contents">
    <h2><a href="#eventdelegation">Делегирование событий</a></h2>
    <ul>
      <li><a href="#apply">Применение делегирования: действия в разметке</a></li>
      <li><a href="#design">Приём проектирования «поведение»</a></li>
      <li><a href="#total">Итого</a></li>
      <li><a href="#tasks">Задачи</a></li>
    </ul>
  </div>

  <div class="topic" id="eventdelegation">
    <h2><a href="https://learn.javascript.ru/event-delegation">Делегирование событий</a></h2>
    <p>Высплытие позволяет создавать в браузере делегирование событий. Смысл его заключается в том, чтобы назначать
      вышестоящим элементам, например <code>document</code> события низлежайших уровней и перехватывать их при
      всплытии проверяя где произошло событие при помощи event.target.</p>
    <p>Далее приводится пример подкрашивания ячеек в таблице на основе:
    <pre>
    <code class="language-js">
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
let selectedTd;
function highlight(td) {
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // подсветить новый td
}        
    </code>
</pre>
    Очередной кусок мутного кода, особенно изначально, но идея я думаю понятна.
    </p>
  </div>
  <div class="topic" id="apply">
    <h3>Применение делегирования: действия в разметке</h3>
    <div id="menu">
      <button data-action="save">Сохранить</button>
      <button data-action="load">Загрузить</button>
      <button data-action="search">Поиск</button>
    </div>

    <script>
      class Menu {
        constructor(elem) {
          elem.onclick = this.onClick.bind(this); // (*)
        }

        save() {
          alert('сохраняю');
        }

        load() {
          alert('загружаю');
        }

        search() {
          alert('ищу');
        }

        onClick(event) {
          let action = event.target.dataset.action;
          if (action) {
            this[action]();
          }
        }
      }

      new Menu(menu);
    </script>
    <p>Можно повесить на каждуй кнопку свой отдельный обработчик, а можно сделать по иному:
    <pre><code class="language-js">
&lt;div id="menu">
  &lt;button data-action="save">Сохранить</button>
  &lt;button data-action="load">Загрузить</button>
  &lt;button data-action="search">Поиск</button>
&lt;/div>

&lt;script>
  class Menu {
    constructor(elem) {
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    }
  }

  new Menu(menu);
  &lt;/script>    
</code></pre>
    Обратите внимание, что метод this.onClick в строке, отмеченной звёздочкой (*), привязывается к контексту текущего
    объекта this. Это важно, т.к. иначе this внутри него будет ссылаться на DOM-элемент (elem), а не на объект Menu, и
    this[action] будет не тем, что нам нужно.
    </p>
  </div>
  <div class="topic" id="design">
    <h3>Приём проектирования «поведение»</h3>
    <p>
      Приём проектирования «поведение» состоит из двух частей:
    <ol>
      <li>Элементу ставится пользовательский атрибут, описывающий его поведение.</li>
      <li>При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если
        элемент имеет нужный атрибут, производит соответствующее действие.</li>
    </ol>
    </p>
    <h4>Поведение: «Счётчик»</h4>
    Счётчик: <input type="button" value="1" data-counter>
    Ещё счётчик: <input type="button" value="2" data-counter>

    <script>
      document.addEventListener('click', function (event) {

        if (event.target.dataset.counter != undefined) { // если есть атрибут...
          event.target.value++;
        }

      });
    </script>
    <pre>
    <code class="language-js">
Счётчик: &lt;input type="button" value="1" data-counter>
Ещё счётчик: &lt;input type="button" value="2" data-counter>

&lt;script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // если есть атрибут...
      event.target.value++;
    }

  });
&lt;/script>        
    </code>
</pre>
    <p>В этом простом примере отражается вся суть паттерна проектирования: поведение вешается на однотипные элементы. В
      данном случае путем добавления свойства data-counter</p>
    <blockquote>
      <h4>Всегда используйте метод addEventListener для обработчиков на уровне документа
      </h4>Чтобы разные обработчики не перезаписывали друг друга.
    </blockquote>
    <h4>Поведение: «Переключатель» (Toggler)</h4>
    <p>Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет скрываться/показываться элемент с заданным id:</p>
    <button data-toggle-id="subscribe-mail">
  Показать форму подписки
</button>

<form id="subscribe-mail" hidden>
  Ваша почта: <input type="email">
</form>

<script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</script>
<pre>
    <code class="language-js">
&lt;button data-toggle-id="subscribe-mail">
  Показать форму подписки
&lt;/button>

&lt;form id="subscribe-mail" hidden>
  Ваша почта: &lt;input type="email">
&lt;/form>

&lt;script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
&lt;/script>        
    </code>
</pre>
  </div>
<div class="topic" id="total">
  <h3>Итого</h3>
  <p>Алгоритм делегирования событий:
<ol>
<li>Вешаем обработчик на контейнер.</li>
<li>В обработчике проверяем исходный элемент event.target.</li>
<li>Если событие произошло внутри нужного нам элемента, то обрабатываем его.  </li>
</ol>
Используем для:
<ul>
  <li>Упрощает процесс инициализации и экономит память, одному обработчику множество элементов.</li>
  <li>При добавлении или удалении элементов не нужно лезь в логику javascript.</li>
<li>Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.</li>

</ul>
Делегирование имеет свои ограничения:
<ul>
<li>Некоторые события не всплывают, так же низкоуровневые обработчики не должны вызывать event.stopPropagation(). </li>  
<li>Делегирование вызывает дополнительную нагрузку, но  как правило она незначительна.</li>
</ul>
  </p>
</div>
<div class="topic" id="tasks">
  <h3>Задачи</h3>
  <div id="task1">
    <h4>Задача 1</h4>
      <div id="container">
        <style>
h3 {
  margin: 0;
  padding-bottom: .3em;
  padding-right: 20px;
  font-size: 1.1em;
}

p {
  margin: 0;
  padding: 0 0 .5em;
}

.pane {
  background: #edf5e1;
  padding: 10px 20px 10px;
  border-top: solid 2px #c4df9b;
  position: relative;
}

.remove-button {
  position: absolute;
  font-size: 110%;
  top: 0;
  color: darkred;
  right: 10px;
  display: block;
  width: 24px;
  height: 24px;
  border: none;
  background: transparent;
  cursor: pointer;
}          
        </style>
    <div class="pane">
      <h3>Лошадь</h3>
      <p>Домашняя лошадь - животное семейства непарнокопытных, одомашненный и единственный сохранившийся подвид дикой лошади, вымершей в дикой природе, за исключением небольшой популяции лошади Пржевальского.</p>
      <button class="remove-button">[x]</button>
    </div>
    <div class="pane">
      <h3>Осёл</h3>
      <p>Домашний осёл или ишак — одомашненный подвид дикого осла, сыгравший важную историческую роль в развитии хозяйства и культуры человека. Все одомашненные ослы относятся к африканским ослам.</p>
      <button class="remove-button">[x]</button>
    </div>
    <div class="pane">
      <h3>Кошка</h3>
      <p>Кошка, или домашняя кошка (лат. Félis silvéstris cátus), — домашнее животное, одно из наиболее популярных (наряду с собакой) "животных-компаньонов". С точки зрения научной систематики, домашняя кошка — млекопитающее семейства кошачьих отряда хищных. Ранее домашнюю кошку нередко рассматривали как отдельный биологический вид.
      </p>
      <button class="remove-button">[x]</button>
    </div>
  </div>
  <script>
    function removeElement(event) {
      if(event.target.className == 'remove-button') event.target.parentNode.style.display = 'none'
    }
    document.addEventListener("click", removeElement)
  </script>
  </div>
</div>









</body>

</html>