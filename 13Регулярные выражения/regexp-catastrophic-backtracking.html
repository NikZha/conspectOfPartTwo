<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Катастрофический возврат или алгоритмическая коллизия.
    </title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#return">Катастрофический возврат</a></h2>
        <ul>
            <li><a href="#example">Пример</a></li>
            <li><a href="#sample">Упрощённый пример</a></li>
            <li><a href="#back">Назад к словам и строкам</a></li>
            <li><a href="#how">Как исправить?</a></li>
            <li><a href="#forbid">Запрет возврата</a></li>
        </ul>
    </div>
    <div class="topic" id="return">
        <h2><a href="https://learn.javascript.ru/regexp-catastrophic-backtracking">Катастрофический возврат</a></h2>
        <p>В уроке речь идёт о том, что в силу реализации, некоторые регекспы могут выполняться очень долго, или вообще
            не смогут быть выполненными. Алгоритмическая сложность в худшем случае <code>2<sup>n</sup>-1</code>.
            То есть для каких-то простых случаев ответ будет получен, а для случаев посложнее ответ не будет получен
            никогда.</p>
    </div>
    <div class="topic" id="example">
        <h3>Пример</h3>
        <p>Для иллюстрации вышесказанного возьмём простой пример: проверка строки на наличие только букв <code>\w</code>
            и
            <code>\s</code> пробелов. Используем регулярное выражение <code>^(\w+\s?)*$</code>, которое задаёт 0 или
            более таких
            слов. Пример работает на мелких строках:
        </p>
        <pre><code class="language-js startbutton" onclick="expl0()">
let regexp = /^(\w+\s?)*$/;

alert( regexp.test("A good string") ); // true
alert( regexp.test("Bad characters: $@#") ); // false            
        </code></pre>
        <script>
            function expl0(params) {
                let regexp = /^(\w+\s?)*$/;

                alert(regexp.test("A good string")); // true
                alert(regexp.test("Bad characters: $@#")); // false                
            }
        </script>
        <p>Однако если взять строку подлиннее, то мы сталкиваемся с алгоритмической сложностью:</p>
        <pre><code class="language-js startbutton">
let regexp = /^(\w+\s?)*$/;
let str = "An input string that takes a long time or even makes this regexp to hang!";

// этот поиск будет выполняться очень, очень долго
alert( regexp.test(str) );            
        </code></pre>
        <p>Сознательно не делаю этот скрипт рабочим - смысла в этом нет, на edge он не отработает, а страница упаддёт в
            ошибку.</p>
    </div>
    <div class="topic" id="sample">
        <h3>Упрощённый пример</h3>
        <p>Ещё один пример состоящий из поиска одних цифр в строке от начала и до конца строки:</p>
        <pre><code class="language-js">
let regexp = /^(\d+)*$/;

let str = "012345678901234567890123456789!";

// этот поиск будет выполняться очень, очень долго
alert( regexp.test(str) );            
        </code></pre>
        <p>И снова на моей системе этот поиск не выполнится никогда. Автор объясняет это жадным поиском отступающим
            назад, когда он в конце наталкивается на <code>!</code>. Перевести поиск в "ленивый" не поможет.</p>
    </div>
    <div class="topic" id="back">
        <h3>Назад к словам и строкам</h3>
        <p>В начальном примере, когда мы ищем слова по шаблону <code>^(\w+\s?)*$</code> в строке вида
            <code>An input that hangs!</code>, происходит то же самое - вместо того, чтобы отметить поиск "увидев" в
            конце <code>!</code>, движок перебирает комбинации составления разных "слов" из имеющихся букв.
        </p>
    </div>
    <div class="topic" id="how">
        <h3>Как исправить?</h3>
        <p>Первых подход - уменьшить возможность движка строить комбинации <code>^(\w+\s)*\w*</code>:</p>
        <pre><code class="language-js startbutton" onclick="expl1()">
let regexp = /^(\w+\s)*\w*$/;
let str = "An input string that takes a long time or even makes this regex to hang!";

alert( regexp.test(str) ); // false            
        </code></pre>
        <script>
            function expl1() {
                let regexp = /^(\w+\s)*\w*$/;
                let str = "An input string that takes a long time or even makes this regex to hang!";

                alert(regexp.test(str)); // false                
            }
        </script>
    </div>







</body>

</html>