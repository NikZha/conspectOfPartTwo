<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fetch</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#fetch">Fetch</a></h2>
        <ul>
            <li><a href="#resp">Заголовки ответа</a></li>
            <li><a href="#req">Заголовки запроса</a></li>
            <li><a href="#post">POST-запросы</a></li>
            <li><a href="#pic">Отправка изображения</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задача</a></li>
        </ul>
    </div>
    <div class="topic" id="fetch">
        <h2>Fetch</h2>
        <p>Для сетевых запросов используется метод(статический класс) <code>fetch</code>:</p>
        <pre><code class="language-js">
let promise = fetch(url, [options])            
        </code></pre>
        <ul>
            <li><code>url</code> – URL для отправки запроса.</li>
            <li><code>options</code> – дополнительные параметры: метод, заголовки и так далее. </li>
        </ul>
        <p>Без <code>options</code> это простой GET-запрос который возвращает объект встроенного класса Response в
            качестве результата, как только сервер пришлёт заголовки ответа. Ошибка возвращется если fetch не смог
            достучаться до ресурса, коды 400-500 ошибками не являются:</p>
        <ul>
            <li><code>status</code> – код статуса HTTP-запроса, например 200.</li>
            <li><code>ok</code> – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299. </li>
        </ul>
        <p>Например: <input type="button" value="Тест fetch" onclick="expl1()"></p>
        <script>
            async function expl1(params) {
                let url = '../index.html'
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    // получаем тело ответа (см. про этот метод ниже)

                    let json = await response.text();
                    alert(json)
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }
            }
        </script>
        <pre><code class="language-js">
                let url = '../index.html'
                let response = await fetch(url);

                if (response.ok) { // если HTTP-статус в диапазоне 200-299
                    // получаем тело ответа (см. про этот метод ниже)
                    
                    let json = await response.text();
                    alert(json)
                } else {
                    alert("Ошибка HTTP: " + response.status);
                }            
        </code></pre>
        <p>Как видно с этого кода, чтобы получить ответ нужно использовать дополнительный вызов, причём получив один,
            нельзя получить другой:</p>
        <ul>
            <li><code>response.text()</code> – читает ответ и возвращает как обычный текст,</li>
            <li><code>response.json()</code> – декодирует ответ в формате JSON,</li>
            <li><code>response.formData()</code> – возвращает ответ как объект FormData (разберём его в следующей
                главе),</li>
            <li><code>response.blob()</code> – возвращает объект как Blob (бинарные данные с типом),</li>
            <li><code>response.arrayBuffer()</code> – возвращает ответ как ArrayBuffer (низкоуровневое представление
                бинарных данных),</li>
            <li>помимо этого, <code>response.body</code> – это объект ReadableStream, с помощью которого можно считывать
                тело запроса по частям. Мы рассмотрим и такой пример несколько позже.</li>

        </ul>
        <p>То же самое без await, с использованием промисов:</p>
        <pre><input type="button" value="Test" onclick="fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));"><code class="language-js">
fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));            
        </code></pre>
        <p>В качестве примера работы с бинарными данными приводится:</p>
        <pre><code class="language-js">
let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // скачиваем как Blob-объект

// создаём &lt;img>
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// выводим на экран
img.src = URL.createObjectURL(blob);

setTimeout(() => { // прячем через три секунды
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);            
        </code></pre>
        <blockquote>
            <h4>Один вариант ответа</h4>
            Как уже было написано ранее можно выбрать 1 вариант ответа, то есть <code>.json()</code>
            после <code>.text()</code> не сработает.
        </blockquote>
    </div>
    <div class="topic" id="resp">
        <h3>Заголовки ответа</h3>
        <p>Заголовки ответа хранятся в похожем на Map объекте <code>response.headers</code>.</p>
        <pre><code class="language-js">
let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// получить один заголовок
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// перебрать все заголовки
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}            
        </code></pre>
        <input type="button" value="Test headers of local fetch" onclick="expl2()">
        <script>
            async function expl2() {
                let response = await fetch('../index.html');

                // получить один заголовок
                alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

                // перебрать все заголовки
                for (let [key, value] of response.headers) {
                    alert(`${key} = ${value}`);
                }
            }
        </script>
    </div>
    <div class="topic" id="req">
        <h3>Заголовки запроса</h3>
        <p>В качестве объекта <code>options</code> можно отправить свойство <code>headers</code> с объектом заголовков.
            Например:</p>
        <pre><code class="language-js">
let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});            
        </code></pre>
        <p>Однако есть заголовки которые нельзя установить:</p>
        <ul>
            <li><code>Accept-Charset, Accept-Encoding</code></li>
            <li><code>Access-Control-Request-Headers</code></li>
            <li><code>Access-Control-Request-Method</code></li>
            <li><code>Connection</code></li>
            <li><code>Content-Length</code></li>
            <li><code>Cookie, Cookie2</code></li>
            <li><code>Date</code></li>
            <li><code>DNT</code></li>
            <li><code>Expect</code></li>
            <li><code>Host</code></li>
            <li><code>Keep-Alive</code></li>
            <li><code>Origin</code></li>
            <li><code>Referer</code></li>
            <li><code>TE</code></li>
            <li><code>Trailer</code></li>
            <li><code>Transfer-Encoding</code></li>
            <li><code>Upgrade</code></li>
            <li><code>Via</code></li>
            <li><code>Proxy-*</code></li>
            <li><code>Sec-*            </code></li>
        </ul>
        <p>Эти заголовки обеспечивают достоверность данных и корректную работу протокола HTTP, поэтому они
            контролируются исключительно браузером.</p>
    </div>
    <div class="topic" id="post">
        <h3>POST-запросы</h3>
        <p>Для <code>fetch</code> используются параметры:</p>
        <ul>
            <li><code>method</code> – HTTP метод, например POST,</li>
            <li><code>body</code> – тело запроса, одно из списка:</li>
            <ul>
                <li>строка (например, в формате JSON),</li>
                <li>объект <code>FormData</code> для отправки данных как <code>form/multipart</code>,</li>
                <li><code>Blob/BufferSource</code> для отправки бинарных данных,</li>
                <li><code>URLSearchParams</code> для отправки данных в кодировке <code>x-www-form-urlencoded</code>,
                    используется
                    редко. </li>
            </ul>
        </ul>
        <p>Например:</p>
        <pre><code class="language-js">
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
//Требуется указать правильный Content-Type если мы шлём json.
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);            
        </code></pre>
    </div>
    <div class="topic" id="pic">
        <h3><a href="https://learn.javascript.ru/fetch#otpravka-izobrazheniya">Отправка изображения</a></h3>
        <p>Мы можем отправить бинарные данные при помощи fetch, используя объекты Blob или BufferSource:</p>
        <pre><code class="language-js">
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });

      // сервер ответит подтверждением и размером изображения
      let result = await response.json();
      alert(result.message);
    }
        </code></pre>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>Типичный запрос с помощью fetch состоит из двух операторов await:</p>
        <pre><code class="language-js">
let response = await fetch(url, options); // завершается с заголовками ответа
let result = await response.json(); // читать тело ответа в формате JSON            
        </code></pre>
        <p>Или, без await:</p>
        <pre><code class="language-js">
fetch(url, options)
  .then(response => response.json())
  .then(result => /* обрабатываем результат */)            
        </code></pre>
        <p>Ответ:</p>
        <ul>
            <li><code>response.status</code> – HTTP-код ответа,</li>
            <li><code>response.ok</code> – true, если статус ответа в диапазоне 200-299.</li>
            <li><code>response.headers</code> – похожий на Map объект с HTTP-заголовками. </li>
        </ul>
        <p>Методы для получения тела ответа: </p>
        <ul>
            <li>response.text()</li> – возвращает ответ как обычный текст,
            <li>response.json()</li> – декодирует ответ в формате <code>JSON</code>,
            <li>response.formData()</li> – возвращает ответ как объект <code>FormData</code> (кодировка form/multipart,
            см. следующую
            главу),
            <li>response.blob()</li> – возвращает объект как <code>Blob</code> (бинарные данные с типом),
            <li>response.arrayBuffer()</li> – возвращает ответ как <code>ArrayBuffer</code> (низкоуровневые бинарные
            данные),
        </ul>
        <p>Опции fetch, которые мы изучили на данный момент:</p>
        <ul>
            <li><code>method</code> – HTTP-метод,</li>
            <li><code>headers</code> – объект с запрашиваемыми заголовками (не все заголовки разрешены),</li>
            <li><code>body</code> – данные для отправки (тело запроса) в виде текста, <code>FormData</code>,
                <code>BufferSource</code>, <code>Blob</code> или <code>UrlSearchParams</code> </li>
        </ul>
    </div>
</body>

</html>