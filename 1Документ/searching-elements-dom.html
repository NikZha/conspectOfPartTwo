<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="widtd=device-width, initial-scale=1.0">
    <title>Поиск: getElement*, querySelector*</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
    <div class="contents">
        <h2><a href="#searching">Поиск: getElement*, querySelector*</a></h2>
        <ul>
            <li><a href="#id">document.getElementById или просто id</a></li>
            <li><a href="#querySelectorAll">querySelectorAll</a></li>
            <li><a href="#querySelector">querySelector</a></li>
            <li><a href="#matches">matches</a></li>
            <li><a href="#closest">closest</a></li>
            <li><a href="#getElementsBy">getElementsBy*</a></li>
            <li><a href="#live">Живые коллекции</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задача</a></li>
        </ul>
    </div>
    <div class="topic" id="searching">
        <h2><a href="https://learn.javascript.ru/searching-elements-dom">Поиск: getElement*, querySelector*</a></h2>
        <p>Рассмотрение методов для получения конкретного элемента</p>
    </div>
    <div class="topic" id="id">
        <h3>document.getElementById или просто id</h3>
        <p id="elem">Этот элемент станет красным - id="elem"</p>
        <p>Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни
            находился.
        <pre><button onclick="let elem = document.getElementById('elem'); // сделать его фон красным
  elem.style.background = 'red'; setTimeout(() => elem.style.background = '', 3000)">Тест кода</button>
    <code class="language-js">
let elem = document.getElementById('elem');  
// сделать его фон красным
elem.style.background = 'red';   
  //А затем обратно бесцеветным через 3 секунды
setTimeout(() => elem.style.background = '', 3000)     
    </code>
</pre>

        </p>
        <p id="noelem">Этот id="noelem" станет красным</p>
        <p>Так же возможно обращение просто по id:
        <pre><button onclick="noelem.style.background = 'red'; setTimeout(() => noelem.style.background = '', 3000 )">Покрасить элемент а потом вернуть обратно</button>
    <code class="language-js">
noelem.style.background = 'red';
setTimeout(() => noelem.style.background = '', 3000 )        
    </code>
</pre>
        В тексте учебника указан id="elem-content", а образение к нему идёт по elem.style.background = 'red'; Но по
        факту в настоящее время это не работает.
        Однако id без тире переменная подхватывает. Так же автор указывает, что такое обращение к переменным
        небезопасно, можно легко объявить переменную с таким же именем и она заменит id.
        <pre><button onclick="  let elem = 5; // теперь elem равен 5, а не 

  alert(elem); // 5">заменить переменную</button>
    <code class="language-js">
  let elem = 5; // теперь elem равен 5, а не &lt;p id="elem">

  alert(elem); // 5        
    </code>
</pre>
        Причём работает оно достаточно непредсказуемо, надо следить на именами.
        </p>
        <blockquote>
            <h4>Только document.getElementById, а не anyElem.getElementById</h4>
            <p>Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему
                документу.</p>
        </blockquote>
    </div>
    <div class="topic" id="querySelectorAll">
        <h3>querySelectorAll</h3>
        <p>Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все элементы внутри elem,
            удовлетворяющие данному CSS-селектору.

            Следующий запрос получает все элементы &lt;li>, которые являются последними потомками в &lt;ul>:
        <ul>
            <li>тест</li>
            <li>пройден</li>
        </ul>
        <pre><button onclick="  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); 
  }">Получить элементы</button>
    <code class="language-js">
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "тест", "пройден"
  }        
    </code>
</pre>
        Этот метод действительно мощный, потому что можно использовать любой CSS-селектор.


        </p>
        <blockquote>
            <h4>Псевдоклассы тоже работают</h4>
            Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например,
            document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из
            текущих элементов под курсором мыши.
        </blockquote>
    </div>
    <div class="topic" id="querySelector">
        <h3>querySelector</h3>
        <p>Метод elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS-селектору.

            <br>Иначе говоря, результат такой же, как при вызове elem.querySelectorAll(css)[0], но он сначала найдёт все
            элементы, а потом возьмёт первый, в то время как elem.querySelector найдёт только первый и остановится. Это
            быстрее, кроме того, его короче писать.
        </p>
    </div>
    <div class="topic" id="matches">
        <h3>matches</h3>
        <p>Предыдущие методы искали по DOM.</p>

        <p>Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true
            или false.</p>

        <p>Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся
            выбрать те из них, которые нас интересуют.</p>
        <p>Например:
            <br><iframe src="searching-expl1.html" frameborder="0"></iframe>
        <pre>
    <code class="language-js">
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }        
    </code>
</pre>
        Маленький нюанс, в этом документе не сработало, пришлось делать отдельный и встраивать iframe потому что
        document.body.children а тут дети только div
        </p>
    </div>
    <div class="topic" id="closest">
        <h3>closest</h3>
        <p>Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также
            включается в поиск.</p>
        <p>Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он
            соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не
            найден.</p>

        <p>Например:
            <br><iframe src="searching-expl2.html" frameborder="0"></iframe>
        <pre>
    <code class="language-js">
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)        
    </code>
</pre>
        И снова это отдельный <a href="searching-expl2.html">пример в отдельном файле.</a>
        </p>
    </div>
    <div class="topic" id="getElementsBy">
        <h3>getElementsBy*</h3>
        <p>На данный момент, они скорее исторические, так как querySelector более чем эффективен.
            Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде.
        <ul>
            <li>elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав "*"
                вместо тега, можно получить всех потомков.</li>
            <li>elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс.</li>
            <li>document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко
                используется.</li>
        </ul>
        Например:
        <pre><button onclick="expl2()">Получить все divs</button>
    <code class="language-js">
// получить все элементы div в документе
let divs = document.getElementsByTagName('div');   
for(let div of divs) alert(div)     
    </code>
</pre>
        <script>
            function expl2(params) {
                // получить все элементы div в документе
                let divs = document.getElementsByTagName('div');
                for (let div of divs) alert(div)
            }
        </script>
        Или более развернутый пример с сайта:
        <br><iframe src="searching-expl3.html" frameborder="0"></iframe>
        </p>
        <blockquote>
            <h4>Не забываем про букву "s"!</h4>
            Без этой буквы один элемент, с ней коллекция. Так же:
            <pre>
    <code class="language-js">
// не работает потому что коллекция
document.getElementsByTagName('input').value = 5; 

// работает (если есть input)
document.getElementsByTagName('input')[0].value = 5;
    </code>
</pre>
        </blockquote>
        <p>Можно получать колекцию и искать по этой же коллекции:
        <pre>
    <code class="language-js">
  // ищем по имени атрибута
  let form = document.getElementsByName('my-form')[0];

  // ищем по классу внутри form
  let articles = form.getElementsByClassName('article');
  alert(articles.length); // 2, находим два элемента с классом article        
    </code>
</pre>
        <iframe src="searching-expl4.html" frameborder="0"></iframe>
        </p>
    </div>
    <div class="topic" id="live">
        <h3>Живые коллекции</h3>
        <p>Все методы "getElementsBy*" возвращают живую коллекцию. Такие коллекции всегда отражают текущее состояние
            документа и автоматически обновляются при его изменении.</p>
        <p>Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов</p>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>
            Есть 6 основных методов поиска элементов в DOM:
        <table>
            <thead>
                <tr>
                    <th>Метод</th>
                    <th>Ищет по...</th>
                    <th>Ищет внутри элемента?</th>
                    <th>Возвращает живую коллекцию?</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>querySelector</td>
                    <td>CSS-selector</td>
                    <td>Да</td>
                    <td>Нет</td>
                </tr>
                <tr>
                    <td>querySelectorAll</td>
                    <td>CSS-selector</td>
                    <td>Да</td>
                    <td>Нет</td>
                </tr>
                <tr>
                    <td>getElementById</td>
                    <td> id</td>
                    <td>Нет</td>
                    <td>Нет</td>
                </tr>
                <tr>
                    <td>getElementsByName</td>
                    <td>name</td>
                    <td>Нет</td>
                    <td>Да</td>
                </tr>
                <tr>
                    <td>getElementsByTagName</td>
                    <td> tag or '*'</td>
                    <td>Да</td>
                    <td>Да</td>
                </tr>
                <tr>
                    <td>getElementsByClassName</td>
                    <td>class</td>
                    <td>Да</td>
                    <td>Да</td>
                </tr>
            </tbody>
        </table>
        Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll, но
        и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.
        Кроме того:
        <ul>
<li>Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору.</li>
<li>Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.            </li>
        </ul>
         ещё один метод, который проверяет наличие отношений между предком и потомком:
         <ul>
            <li>elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB</li>
         </ul>
        </p>

    </div>
    <div class="topic" id="tasks">
        <h3>Задача </h3>
        <p>
            <iframe src="searching-task1.html" frameborder="0"></iframe>
        </p>
    </div>