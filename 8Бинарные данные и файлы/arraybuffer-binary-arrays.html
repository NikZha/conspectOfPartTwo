<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArrayBuffer, бинарные массивы</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#arraybuffe">ArrayBuffer, бинарные массивы</a></h2>
        <ul>
            <li><a href="#TypedArray">TypedArray</a></li>
            <li><a href="#methods">Методы TypedArray</a></li>
            <li><a href="#DataView">DataView</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задачи</a></li>
        </ul>
    </div>
    <div class="topic" id="arraybuffe">
        <h2><a href="https://learn.javascript.ru/arraybuffer-binary-arrays">ArrayBuffer, бинарные массивы</a></h2>
        <p>ArrayBuffer - класс для выделения памяти под бинарные данные:</p>
        <pre><code class="language-js">
let buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт
alert(buffer.byteLength); // 16        
    </code></pre>
        <p>Выделяется непрерывный массив (виртуальной) памяти который заполняется нулями. Динамически увеличить нельзя,
            занимает в памяти столько сколько указано при инициализации (скорее всего пиздёшь, так как имеет
            вспомогательные
            методы). Требует интерпретации.</p>
        <p>Для интертрепации ArrayBuffer есть минимум 4 класса:</p>
        <li><code>Uint8Array</code>, <code>Uint16Array</code>, <code>Uint32Array</code> - как следует из названия uint'ы
            соотвествующей разрядности.</li>
        <li><code>Float64Array</code> - типичный Double64.</li>
        <p>Соотвественно, так как память выделяется в байтах - размер ячейки будет равен выбранному типу, например:</p>
        <pre><code class="language-js">
let buffer = new ArrayBuffer(16); // создаётся буфер длиной 16 байт

let view = new Uint32Array(buffer); // интерпретируем содержимое как последовательность 32-битных целых чисел без знака

alert(Uint32Array.BYTES_PER_ELEMENT); // 4 байта на каждое целое число

alert(view.length); // 4, именно столько чисел сейчас хранится в буфере
alert(view.byteLength); // 16, размер содержимого в байтах

// давайте запишем какое-нибудь значение
view[0] = 123456;

// теперь пройдёмся по всем значениям
for(let num of view) {
  alert(num); // 123456, потом 0, 0, 0 (всего 4 значения)
}        
    </code></pre>
    </div>
    <div class="topic" id="TypedArray">
        <h3>TypedArray</h3>
        <p>Для работы с численным представлением есть <code>TypedArray</code> у которого есть типовые методы для работы
            с
            ячейками памяти, как у обычного массива.</p>
        <p>Варианты создания объекта <code>TypedArray</code>:</p>
        <pre><code class="language-js">
new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();            
        </code></pre>
        <p>Далее обсуждается вопросы инициализации этого класса и что происходит при переполнении буфера.</p>
    </div>
    <div class="topic" id="methods">
        <h3>Методы TypedArray</h3>
        <p><code>TypedArray</code> имеет почти такие же методы как и <code>Array</code>. За некоторым исключением:</p>
        <ul>
            <li>Нет метода <code>splice</code> – мы не можем удалять значения, потому что типизированные массивы – это
                всего лишь представления данных из буфера, а буфер – это непрерывная область памяти фиксированной длины.
                Мы можем только записать 0 вместо значения.</li>
            <li>Нет метода concat. </li>
        </ul>
        <p>И есть два других метода:</p>
        <ol>
            <li><code>arr.set(fromArr, [offset])</code> копирует все элементы из <code>fromArr</code> в
                <code>arr</code>, начиная с позиции <code>offset</code> (0 по умолчанию).
            </li>
            <li><code>arr.subarray([begin, end])</code> создаёт новое представление того же типа для данных, начиная с
                позиции begin до end (не включая). Это похоже на метод slice (который также поддерживается), но при этом
                ничего не копируется – просто создаётся новое представление, чтобы совершать какие-то операции над
                указанными данными. </li>
        </ol>
    </div>
    <div class="topic" id="DataView">
        <h3>DataView</h3>
        <p>Это средство просмотра бинарных буферов, позволяющее интерпретировать данные в режиме
            <code>.getUint8(i)</code>, <code>.getUint16(i)</code> и так далее.</p>
            <pre><code class="language-js">
new DataView(buffer, [byteOffset], [byteLength])                
            </code></pre>
            <p>где:</p>
            <ul>
<code>buffer</code> – ссылка на бинарные данные ArrayBuffer. В отличие от типизированных массивов, DataView не создаёт буфер автоматически. Нам нужно заранее подготовить его самим.
<code>byteOffset</code> – начальная позиция данных для представления (по умолчанию 0).
<code>byteLength</code> – длина данных (в байтах), используемых в представлении (по умолчанию – до конца buffer).                
            </ul>
            <p>Пример:</p>
            <pre><code class="language-js">
// бинарный массив из 4х байт, каждый имеет максимальное значение 255
let buffer = new Uint8Array([255, 255, 255, 255]).buffer;

let dataView = new DataView(buffer);

// получим 8-битное число на позиции 0
alert( dataView.getUint8(0) ); // 255

// а сейчас мы получим 16-битное число на той же позиции 0, оно состоит из 2-х байт, вместе составляющих число 65535
alert( dataView.getUint16(0) ); // 65535 (максимальное 16-битное беззнаковое целое)

// получим 32-битное число на позиции 0
alert( dataView.getUint32(0) ); // 4294967295 (максимальное 32-битное беззнаковое целое)

dataView.setUint32(0, 0); // при установке 4-байтового числа в 0, во все его 4 байта будут записаны нули                
            </code></pre>
    </div>

</body>

</html>