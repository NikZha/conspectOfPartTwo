<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Общение между окнами</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#conversation">Общение между окнами</a></h2>
        <ul>
            <li><a href="#loan">Политика "Одинакового источника"</a></li>
            <li><a href="#domain">Окна на поддоменах: document.domain</a></li>
            <li><a href="#frames">Коллекция window.frames</a></li>
            <li><a href="#sandbox">Атрибут ифрейма sandbox</a></li>
            <li><a href="#messages">Обмен сообщениями между окнами</a></li>
            <li><a href="#total">Итого</a></li>
        </ul>
    </div>
    <div class="topic" id="conversation">
        <h2><a href="https://learn.javascript.ru/cross-window-communication">Общение между окнами</a></h2>
        <p>Задача политики «Одинакового источника» не дать красть информацию используя скрипты одного сайта с другого
            сайта. </p>
    </div>
    <div class="topic" id="loan">
        <h3>Политика "Одинакового источника"</h3>
        <p>Одинаковый источник:</p>
        <ul>

            <li><code>http://site.com</code></li>
            <li><code>http://site.com/</code></li>
            <li><code>http://site.com/my/page.html</code></li>

        </ul>
        <p>Разные источники:</p>
        <ul>

            <li><code>http://www.site.com</code> (другой домен: <code>www.</code> важен)</li>
            <li><code>http://site.org</code> (другой домен: <code>.org</code> важен)</li>
            <li><code>https://site.com</code> (другой протокол: <code>https</code>)</li>
            <li><code>http://site.com:8080</code> (другой порт: <code>8080</code>)</li>

        </ul>
        <p>Политика "Одинакового источника" говорит:</p>
        <ul>
            <li>если у нас есть ссылка на другой объект <code>window</code>, например, на всплывающее окно, созданное с
                помощью window.open или на window из <code>&lt;iframe></code> и у этого окна тот же источник, то к нему
                будет полный доступ.</li>
            <li>в противном случае, если у него другой источник, мы не сможем обращаться к его переменным, объекту
                <code>document</code> и так далее. Единственное исключение – объект <code>location</code>: его можно
                изменять (таким образом перенаправляя пользователя). Но нельзя читать location (нельзя узнать, где
                находится пользователь, чтобы не было никаких утечек информации)
            </li>
        </ul>
        <div id="access">
            <h3>Доступ к содержимому ифрейма</h3>
            <p><code>&lt;ifame&gt;</code> имеет свои собственные свойства <code>document</code> и <code>window</code> и
                мы можем к ним обратиться:</p>
            <ul>
                <li><code>iframe.contentWindow</code> ссылка на объект <code>window</code> внутри
                    <code>&lt;iframe></code>.
                </li>
                <li><code>iframe.contentDocument</code> – ссылка на объект <code>document</code> внутри
                    <code>&lt;iframe></code>, короткая запись для <code>iframe.contentWindow.document</code>.
                </li>
            </ul>
            <p>И тут работает политика Одинакового источника:</p>
            <pre><code class="language-js">
&lt;iframe src="https://example.com" id="iframe"&gt;&lt;/iframe&gt;

&lt;script&gt;
  iframe.onload = function() {
    // можно получить ссылку на внутренний window
    let iframeWindow = iframe.contentWindow; // OK

    // ...но при попытке получить доступ к document страницы

    let doc = iframe.contentDocument; // ...получим null

    // также мы не можем прочитать URL страницы в ифрейме
    try {
      // нельзя читать из объекта Location
      let href = iframe.contentWindow.location.href; // ОШИБКА
    } catch(e) {
      alert(e); // Security Error
    }

    // ...но можно писать в него (и загрузить что-то другое в ифрейм)!
    iframe.contentWindow.location = '/'; // OK

    iframe.onload = null; // уберём обработчик, чтобы не срабатывал после изменения location
  };
&lt;/script&gt;                
            </code></pre>
            <details>
                <summary>Соотвественно для одной локации это все будет работать:</summary>
                <!-- ифрейм с того же сайта -->
                <iframe src="/" id="iframe" name="win"></iframe>

                <script>
                    iframe.onload = function () {
                        // делаем с ним что угодно
                        iframe.contentDocument.body.prepend("Привет, мир!");
                    };
                </script>
            </details>
            <pre><code class="language-js">
&lt;!-- ифрейм с того же сайта --&gt;
&lt;iframe src="/" id="iframe"&gt;&lt;/iframe&gt;

&lt;script&gt;
  iframe.onload = function() {
    // делаем с ним что угодно
    iframe.contentDocument.body.prepend("Привет, мир!");
  };
&lt;/script&gt;                
            </code></pre>
            <p>Работать внутри просмотра запущенного с vscode.</p>
            <blockquote>
                <h4><code>iframe.onload</code> и <code>iframe.contentWindow.onload</code></h4>
                <p>Событие <code>iframe.onload</code> – по сути то же, что и <code>iframe.contentWindow.onload</code>.
                    Оно сработает, когда встроенное окно полностью загрузится со всеми ресурсами.</p>

                <p>…Но <code>iframe.onload</code> всегда доступно извне ифрейма, в то время как доступ к
                    <code>iframe.contentWindow.onload</code> разрешён только из окна с тем же источником.
                </p>

            </blockquote>
        </div>
    </div>
    <div class="topic" id="domain">
        <h3>Окна на поддоменах: document.domain</h3>
        <p>Для взаимодействия документов на поддоменах в на каждой странице поддомена надо запустить:</p>
        <pre><code class="language-js">
document.domain = 'site.com';            
        </code></pre>
        <p>Но сработает это только на домене второго уровня.</p>
        <div id="wait">
            <h3>iframe: подождите документ</h3>
            <pre><code class="language-js">
&lt;iframe src="/" id="iframe"&gt;&lt;/iframe&gt;

&lt;script&gt;
  let oldDoc = iframe.contentDocument;
  iframe.onload = function() {
    let newDoc = iframe.contentDocument;
    // загруженный document - не тот, который был в iframe при создании изначально!
    alert(oldDoc == newDoc); // false
  };
&lt;/script&gt;                
            </code></pre>
            <p>То есть работать с фреймом надо тогда когда он загрузился и помочь в этом может
                <code>iframe.onload</code>, но срабатывает он единожды, автор предлагает проверять через мутноватый
                скрипт:
            </p>
            <pre><code class="language-js">
&lt;iframe src="/" id="iframe">&lt;/iframe>

&lt;script>
  let oldDoc = iframe.contentDocument;

  // каждый 100 мс проверяем, не изменился ли документ
  let timer = setInterval(() => {
    let newDoc = iframe.contentDocument;
    if (newDoc == oldDoc) return;

    alert("New document is here!");

    clearInterval(timer); // отключим setInterval, он нам больше не нужен
  }, 100);
&lt;/script>                
            </code></pre>
            <p>Как я понимаю, вместо алерта - предлагается работать с той ссылкой которая появилась, например приравняя
                её к старой ссылке и работая с ней.</p>
        </div>

    </div>
    <div class="topic" id="frames">
        <h3>Коллекция window.frames</h3>
        <p>Пара способов для получения ссылки на <code>&lt;frame&gt;</code>:</p>
        <li>В массиве по номеру например - <code>woindow.frames[0]</code>.</li>
        <li>По имени, как свойстве фрейма <code>name="iframeName"</code> - <code>window.frames.iframeName</code></li>
        <footer>Например:</footer>
        <pre><input type="button" value="Потестить скрипт" onclick="expl1">
            <code class="language-js">
&lt;iframe src="/" style="height:80px" name="win" id="iframe">&lt;/iframe>

&lt;script>
  alert(iframe.contentWindow == frames[0]); // true
  alert(iframe.contentWindow == frames.win); // true
&lt;/script>            
        </code></pre>
        <script>
            function expl1() {
                let scr = document.createElement('script');
                let str = `                
  alert(iframe.contentWindow == frames[0]); // true
  alert(iframe.contentWindow == frames.win); // true
        `;
                scr.innerHTML = str;
                document.body.append(scr)
            }

        </script>
        <details>
            <summary>Открыть подробности работы кнопки</summary>
            <p>Свойство <code>name="win"</code> было засунуто первому <code>iframe</code>, а скрипт динамически
                создаётся
                функцией и инжектится в документ.</p>
        </details>
        <p>Однако фреймы тоже могут иметь фреймы, навигация по ним выглядит так:</p>
        <ul>
            <li><code>window.frames</code> – коллекция «дочерних» window (для вложенных фреймов).</li>
            <li><code>window.parent</code> – ссылка на «родительский» (внешний) window.</li>
            <li><code>window.top</code> – ссылка на самого верхнего родител </li>
        </ul>
        <footer>Например:</footer>
        <pre><code class="language-js">
window.frames[0].parent === window; // true

if (window == top) { // текущий window == window.top?
  alert('Скрипт находится в самом верхнем объекте window, не во фрейме');
} else {
  alert('Скрипт запущен во фрейме!');
}
        </code></pre>
    </div>
    <div class="topic" id="sandbox">
        <h3>Атрибут ифрейма sandbox</h3>
        <p>Атрибут <code>sandbox</code> помещает фрейм в песочницу с кучей ограничений - запрещены скрипты, отправка
            форм и т.д.</p>
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/iframe">Подробнее</a> в
            справочнике.</p>
        <blockquote>
            Атрибут "sandbox" создан только для того, чтобы добавлять ограничения. Он не может удалять их. В частности,
            он не может ослабить ограничения, накладываемые браузером на ифрейм, приходящий с другого источника.
        </blockquote>
    </div>




</body>

</html>