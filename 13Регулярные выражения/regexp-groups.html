<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Скобочные группы</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#bracket">Скобочные группы</a></h2>
        <ul>
            <li><a href="#examples">Примеры</a></li>
            <li><a href="#match">Содержимое скобок в match</a></li>
            <li><a href="#matchall">Поиск всех совпадений с группами: matchAll</a></li>
            <li><a href="#named">Именованные группы</a></li>
            <li><a href="#replace">Скобочные группы при замене</a></li>
            <li><a href="#exeption">Исключение из запоминания через ?:</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задачи</a></li>
        </ul>
    </div>
    <div class="topic" id="bracket">
        <h2><a href="https://learn.javascript.ru/regexp-groups">Скобочные группы</a></h2>
        <p>Часть шаблона можно заключить в скобки <code>(...)</code>. Это называется «скобочная группа».

            У такого выделения есть два эффекта:</p>
        <ol>
            <li>Позволяет поместить часть совпадения в отдельный массив.</li>
            <li>Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к
                одному символу. </li>
        </ol>
    </div>
    <div class="topic" id="examples">
        <h3>Примеры</h3>
        <div id="repeat">
            <h4>Пример: gogogo</h4>
            <pre><code class="language-js startbutton" onclick="expl0()">
alert( 'Gogogo now!'.match(/(go)+/ig) ); // "Gogogo"            
        </code></pre>
            <script>
                function expl0() {
                    alert('Gogogo now!'.match(/(go)+/ig)); // "Gogogo"                
                }
            </script>
            <p>В этом примере происходит поиск повторяющегося выражения <code>go</code> которое стоит в скобках.</p>
        </div>
        <div id="domen">
            <h4>Пример: домен</h4>
            <p>Поиск домена в тексте:</p>
            <pre><code>
mail.com
users.mail.com
smith.users.mail.com                
            </code></pre>
            <p>Для поиска используется регексп <code>(\w+\.)+\w+</code>:</p>
            <pre><code class="language-js startbutton" onclick="expl1()">
let regexp = /(\w+\.)+\w+/g;

alert( "site.com my.site.com".match(regexp) ); // site.com,my.site.com                
            </code></pre>
            <script>
                function expl1() {
                    let regexp = /(\w+\.)+\w+/g;

                    alert("site.com my.site.com".match(regexp)); // site.com,my.site.com                    
                }
            </script>
            <p>Пример наивный потому что не учитывает <code>-</code>, что можно исправить <code>([\w-]+\.)+\w+</code>.
            </p>
        </div>
        <div id="email">
            <h4>Пример: email</h4>
            <pre><code class="language-js startbutton" onclick="expl2()">
let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

alert("my@mail.com @ his@site.com.uk".match(regexp)); // my@mail.com, his@site.com.uk                
            </code></pre>
            <script>
                function expl2() {
                    let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

                    alert("my@mail.com @ his@site.com.uk".match(regexp)); // my@mail.com, his@site.com.uk                    
                }
            </script>
        </div>
    </div>
    <div class="topic" id="match">
        <h3>Содержимое скобок в match</h3>
        <p>Метод <code>str.match(regexp)</code>, если у регулярного выражения <code>regexp</code> нет флага
            <code>g</code>, ищет первое совпадение и возвращает его в виде массива:
        </p>
        <ol>
            <li>На позиции 0 будет всё совпадение целиком.</li>
            <li>На позиции 1 – содержимое первой скобочной группы.</li>
            <li>На позиции 2 – содержимое второй скобочной группы.</li>
            <li>…и так далее… </li>
        </ol>
        <p>Например:</p>
        <pre><code class="language-js startbutton" onclick="expl3()">
let str = '<h1>Hello, world!</h1>';

let tag = str.match(/&lt;(.*?)>/);

alert( tag[0] ); // &lt;h1>
alert( tag[1] ); // h1            
        </code></pre>
        <script>
            function expl3() {
                let str = '<h1>Hello, world!</h1>';

                let tag = str.match(/<(.*?)>/);

                alert(tag[0]); // <h1>
                alert(tag[1]); // h1                
            }
        </script>
        <div id="include">
            <h4>Вложенные группы</h4>
            <p>Круглые скобки в регекспе могут быть вложенными например для поиска HTML-тегов вида
                <code>&lt;span class="my"&gt;</code> можно использовать регексп <code>&lt;(([a-z]+)\s*([^>]*))></code>
                который позволит:
            </p>
            <ol>
                <li>Показать содержимое тега целиком.</li>
                <li>Отдельно показать название тега.</li>
                <li>Отдельно показать атрибуты тега.</li>
            </ol>
            <pre><code class="language-js startbuttont" onclick="expl4()">
let str = '&lt;span class="my">';

let regexp = /&lt;(([a-z]+)\s*([^>]*))>/;

let result = str.match(regexp);
alert(result[0]); // &lt;span class="my">
alert(result[1]); // span class="my"
alert(result[2]); // span
alert(result[3]); // class="my"                
            </code></pre>
            <script>
                function expl4() {
                    let str = '<span class="my">';

                    let regexp = /<(([a-z]+)\s*([^>]*))>/;

                    let result = str.match(regexp);
                    alert(result[0]); // <span class="my">
                    alert(result[1]); // span class="my"
                    alert(result[2]); // span
                    alert(result[3]); // class="my"                    
                }
            </script>
        </div>
        <div id="optional">
            <h4>Необязательные группы</h4>
            <p>Если группа необязательная и совпадение по ней нет, то в массиве ставиться <code>undefined</code> вместо
                значения. Например:</p>
            <pre><code class="language-js startbutton" onclick="expl5()">
let match = 'ac'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // ac (всё совпадение)
alert( match[1] ); // undefined, потому что для (z)? ничего нет
alert( match[2] ); // c                    
                </code></pre>
            <script>
                function expl5() {
                    let match = 'ac'.match(/a(z)?(c)?/)

                    alert(match.length); // 3
                    alert(match[0]); // ac (всё совпадение)
                    alert(match[1]); // undefined, потому что для (z)? ничего нет
                    alert(match[2]); // c                        
                }
            </script>
        </div>
    </div>
    <div class="topic" id="matchall">
        <h3>Поиск всех совпадений с группами: matchAll</h3>
        <p>Ряд особенностей функции <code>matchAll</code>:</p>
        <ul>
            <li>Он возвращает не массив, а перебираемый объект.</li>
            <li>При поиске с флагом <code>g</code>, он возвращает каждое совпадение в виде массива со скобочными
                группами.</li>
            <li>Если совпадений нет, он возвращает не <code>null</code>, а просто пустой перебираемый объект.</li>
        </ul>
        <p>Например:</p>
        <pre><code class="language-js startbutton" onclick="expl6()">
let results = '&lt;h1> &lt;h2>'.matchAll(/&lt;(.*?)>/gi);

// results - не массив, а перебираемый объект
alert(results); // [object RegExp String Iterator]

alert(results[0]); // undefined (*)

results = Array.from(results); // превращаем в массив

alert(results[0]); // &lt;h1>,h1 (первый тег)
alert(results[1]); // &lt;h2>,h2 (второй тег)            
        </code></pre>
        <script>
            function expl6() {
                let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

                // results - не массив, а перебираемый объект
                alert(results); // [object RegExp String Iterator]

                alert(results[0]); // undefined (*)

                results = Array.from(results); // превращаем в массив

                alert(results[0]); // <h1>,h1 (первый тег)
                alert(results[1]); // <h2>,h2 (второй тег)                
            }
        </script>
    </div>
    <div class="topic" id="named">
        <h3>Именованные группы</h3>
        <p>Для обозначения групп в коде используется выражение <code>?&lt;name></code> после открытия круглой скобки,
            например:</p>
        <pre><code class="language-js startbutton" onclick="expl7()">
let dateRegexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/;
let str = "2019-04-30";

let groups = str.match(dateRegexp).groups;

alert(groups.year); // 2019
alert(groups.month); // 04
alert(groups.day); // 30            
        </code></pre>
        <script>
            function expl7() {
                let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
                let str = "2019-04-30";

                let groups = str.match(dateRegexp).groups;

                alert(groups.year); // 2019
                alert(groups.month); // 04
                alert(groups.day); // 30
                alert(typeof (dateRegexp))
            }
        </script>
        <p>Флаг регекспа <code>g</code> и <code>matchAll()</code> позволяют получать все совпадения:</p>
        <pre><code class="language-js startbutton" onclick="expl8()">
let dateRegexp = /(?&lt;year>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/g;

let str = "2019-10-30 2020-01-01";

let results = str.matchAll(dateRegexp);

for(let result of results) {
  let {year, month, day} = result.groups;

  alert(`${day}.${month}.${year}`);
  // первый вывод: 30.10.2019
  // второй: 01.01.2020
}            
        </code></pre>
        <script>
            function expl8() {
                let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

                let str = "2019-10-30 2020-01-01";

                let results = str.matchAll(dateRegexp);

                for (let result of results) {
                    let { year, month, day } = result.groups;

                    alert(`${day}.${month}.${year}`);
                    // первый вывод: 30.10.2019
                    // второй: 01.01.2020
                }
            }
        </script>
    </div>
    <div class="topic" id="replace">
        <h3>Скобочные группы при замене</h3>
        <p>Метод <code>str.replace(regexp, replacement)</code> позволяет использовать группы: </p>
        <ul>
            <li>Неименнованные группы используют обозначения вида <code>$n</code>, где <code>n</code>– номер скобочной
                группы. Например:
                <pre><code class="language-js startbutton" onclick="expl9()">
let str = "John Bull";
let regexp = /(\w+) (\w+)/;

alert( str.replace(regexp, '$2, $1') ); // Bull, John                
            </code></pre>
                <script>
                    function expl9() {
                        let str = "John Bull";
                        let regexp = /(\w+) (\w+)/;

                        alert(str.replace(regexp, '$2, $1')); // Bull, John                    
                    }
                </script>
            </li>
            <li>Именованные скобочные группы - вызываются по именам:
                <pre><code class="language-js startbutton" onclick="expl10()">
let regexp = /(?&lt;ear>[0-9]{4})-(?&lt;month>[0-9]{2})-(?&lt;day>[0-9]{2})/g;

let str = "2019-10-30, 2020-01-01";

alert( str.replace(regexp, '$&lt;day>.$&lt;month>.$&lt;year>') );
// 30.10.2019, 01.01.2020                
            </code></pre>
                <script>
                    function expl10() {
                        let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

                        let str = "2019-10-30, 2020-01-01";

                        alert(str.replace(regexp, '$<day>.$<month>.$<year>'));
                        // 30.10.2019, 01.01.2020        
                    }
                </script>
            </li>
        </ul>
    </div>
    <div class="topic" id="exeption">
        <h3>Исключение из запоминания через ?:</h3>
        <p>Скобочную группу можно исключить из запоминаемых добавив в её начало <code>?:</code></p>
        <pre><code class="language-js" onclick="expl11()">
let str = "Gogogo John!";

// ?: исключает go из запоминания
let regexp = /(?:go)+ (\w+)/i;

let result = str.match(regexp);

alert( result[0] ); // Gogogo John (полное совпадение)
alert( result[1] ); // John
alert( result.length ); // 2 (больше в массиве элементов нет)            
        </code></pre>
        <script>
            function expl11() {
                let str = "Gogogo John!";

                // ?: исключает go из запоминания
                let regexp = /(?:go)+ (\w+)/i;

                let result = str.match(regexp);

                alert(result[0]); // Gogogo John (полное совпадение)
                alert(result[1]); // John
                alert(result.length); // 2 (больше в массиве элементов нет)                
            }
        </script>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>Скобочные группы - это выражения в скобках <code>(...)</code> которое воспринимается как единое целое.</p>
        <p>Функция <code>match</code> возвращает на нулевой позиции совпадение целиком, а далее выражения в скобочных
            групах.</p>
        <p>Функция <code>matchAll</code> возвращает объект с похожими на <code>match</code> позициями, но по всем
            совпадениям.</p>
        <p>Группы могут быть именованными <code>?&lt;name&gt;</code> или не именнованными, и тогда можно использовать
            имена групп в функциях или использовать номера групп если группы не именованные.</p>
        <p>Можно исключить из запоминания группу при помощи подстановки в начало <code>?:</code>.</p>
    </div>
    <div class="topic" id="tasks">
        <h3>Задачи</h3>
        <div id="task1">
            <h4>Задача 1 Проверьте MAC-адрес</h4>
            <input type="button" value="Задача 1" onclick="task1()">
            <p>Мой регексп: <code>/(((\p{Hex_Digit}\p{Hex_Digit}):){5}(\p{Hex_Digit}\p{Hex_Digit}){1})/u</code></p>
            <p>Регексп который предлагает автор - <code>/^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i</code></p>
            <p>Я хз, но мой регексп проходит тесты автора.</p>
            <script>
                function task1() {
                    let regexp = /(((\p{Hex_Digit}\p{Hex_Digit}):){5}(\p{Hex_Digit}\p{Hex_Digit}){1})/u;

                    alert(regexp.test('01:32:54:67:89:AB')); // true

                    alert(regexp.test('0132546789AB')); // false (нет двоеточий)

                    alert(regexp.test('01:32:54:67:89:AB')); // false (5 чисел, должно быть 6)

                    alert(regexp.test('01:32:54:67:89:ZZ')) // false (ZZ в конце строки)
                }
            </script>
        </div>
        <div id="task2">
            <h4>Задача 2 Найти цвет в формате #abc или #abcdef</h4>
            <input type="button" value="Задача 2" onclick="task2()">
            <p>Задача не решена самостоятельно, автор использовал хитрый поиск вида:
                <code>let regexp = /(#(\p{Hex_Digit}{3}){1,2}\b)/gu;</code> в котором поисковая группа заключена
                между <code>#</code> и группой <code>{1,2}</code>.
            </p>
            <script>
                function task2() {
                    let regexp = /(#(\p{Hex_Digit}{3}){1,2}\b)/gu;

                    let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

                    alert(str.match(regexp)); // #3f3 #AA00ef                    
                }
            </script>
        </div>
        <div id="task3">
            <h4>Задача 3 Найти все числа</h4>
            <input type="button" value="Задача 3" onclick="task3()">
            <p>Мой регексп <code>let regexp = /(\b([-])*(\d{1,}\.*(d{1,})*\b)+)/g;</code>. Проходит тесты автора.</p>
            <p>Регексп автора <code>let regexp = /-?\d+(\.\d+)?/g;</code> - из плюсов использован более подходящий
                квартификатор.</p>
            <script>
                function task3() {
                    let regexp = /(\b([-])*(\d{1,}\.*(d{1,})*\b)+)/g;

                    let str = "-1.5 0 2 -123.4.";

                    alert(str.match(regexp)); // -1.5, 0, 2, -123.4
                }
            </script>
        </div>
    </div>







</body>

</html>