<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLHttpRequest</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#XMLHttpRequest">XMLHttpRequest</a></h2>
        <ul>
            <li><a href="#basics">Основы</a></li>
            <li><a href="#type">Тип ответа</a></li>
            <li><a href="#req">Состояния запроса</a></li>
            <li><a href="#cansel">Отмена запроса</a></li>
            <li><a href="#sync">Синхронные запросы</a></li>
            <li><a href="#headers">HTTP-заголовки</a></li>
            <li><a href="#post">POST, FormData</a></li>
            <li><a href="#progress">Прогресс отправки</a></li>
            <li><a href="#cors">Запросы на другой источник</a></li>
            <li><a href="#total">Итого</a></li>
        </ul>
    </div>
    <div class="topic" id="XMLHttpRequest">
        <h2><a href="https://learn.javascript.ru/xmlhttprequest">XMLHttpRequest</a></h2>
        <p>Встроенный в браузер объект навроде <code>fetch</code> только старше, используется по 3 причинам:</p>
        <ol>
            <li>По историческим причинам: существует много кода, использующего <code>XMLHttpRequest</code>, который
                нужно поддерживать.</li>
            <li>Необходимость поддерживать старые браузеры и нежелание использовать полифилы (например, чтобы уменьшить
                количество кода).</li>
            <li>Потребность в функциональности, которую <code>fetch</code> пока что не может предоставить, к примеру,
                отслеживание прогресса отправки на сервер. </li>
        </ol>
    </div>
    <div class="topic" id="basics">
        <h3>Основы</h3>
        <pre><code class="language-js">
let xhr = new XMLHttpRequest(); // у конструктора нет аргументов
//Далее рулится методами по типу:
xhr.open(method, URL, [async, user, password])            
        </code></pre>
        <p>Где:</p>
        <ul>
            <li><code>method</code> – HTTP-метод. Обычно это <code>"GET"</code> или <code>"POST"</code> .</li>
            <li><code>URL</code> – URL, куда отправляется запрос: строка, может быть и объект URL.</li>
            <li><code>async</code> – если указать <code>false</code>, тогда запрос будет выполнен синхронно, это мы
                рассмотрим чуть позже.</li>
            <li><code>user</code>, <code>password</code> – логин и пароль для базовой HTTP-авторизации (если требуется)
            </li>
        </ul>
        <p>Однако метод <code>open</code> лишь конфигурирует запрос, но не отправляет его, чтобы отправить запрос,
            нужно:</p>
        <pre><code class="language-js">
xhr.send([body])            
        </code></pre>
        <p>Где <code>body</code> необязательный параметр, но нужен для <code>POST</code>.</p>
        <p>У этого объекта <code>xhr</code> есть события:</p>
        <ul>
            <li><code>load</code> – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например
                404.</li>
            <li><code>error</code> – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.
            </li>
            <li><code>progress</code> – происходит периодически во время загрузки ответа, сообщает о прогрессе. </li>
        </ul>
        <p>Например:</p>
        <pre><code class="language-js">
// 1. Создаём новый XMLHttpRequest-объект
let xhr = new XMLHttpRequest();

// 2. Настраиваем его: GET-запрос по URL /article/.../load
xhr.open('GET', '/article/xmlhttprequest/example/load');

// 3. Отсылаем запрос
xhr.send();

// 4. Этот код сработает после того, как мы получим ответ сервера
xhr.onload = function() {
  if (xhr.status != 200) { // анализируем HTTP-статус ответа, если статус не 200, то произошла ошибка
    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`); // Например, 404: Not Found
  } else { // если всё прошло гладко, выводим результат
    alert(`Готово, получили ${xhr.response.length} байт`); // response -- это ответ сервера
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Получено ${event.loaded} из ${event.total} байт`);
  } else {
    alert(`Получено ${event.loaded} байт`); // если в ответе нет заголовка Content-Length
  }

};

xhr.onerror = function() {
  alert("Запрос не удался");
};            
        </code></pre>
        <p>После получения ответа у объекта появляются следующие свойства:</p>
        <ul>
            <li><code>status</code> <br>
                Код состояния HTTP (число): 200, 404, 403 и так далее, может быть 0 в случае, если ошибка не связана с
                HTTP.</li>
            <li><code>statusText</code> <br>
                Сообщение о состоянии ответа HTTP (строка): обычно OK для 200, Not Found для 404, Forbidden для 403, и
                так далее.</li>
            <li><code>response</code> (в старом коде может встречаться как responseText) <br>
                Тело ответа сервера. </li>
        </ul>
        <pre><code class="language-js">
xhr.timeout = 10000; // таймаут ожидания ответа указывается в миллисекундах, т.е. 10 секунд            
        </code></pre>
        <blockquote>
            <h4>URL с параметрами</h4>
            <p><code>XMLHttpRequest</code> кооректно работает с объектом <code>URL</code>:</p>
            <pre><code class="language-js">
let url = new URL('https://google.com/search');
url.searchParams.set('q', 'test me!');

// параметр 'q' закодирован
xhr.open('GET', url); // https://google.com/search?q=test+me%21            
        </code></pre>
        </blockquote>
    </div>
    <div class="topic" id="type">
        <h3><a href="https://learn.javascript.ru/xmlhttprequest#tip-otveta">Тип ответа</a></h3>
        <p>Мы можем задать свойство <code>xhr.responseType</code>, чтобы указать ожидаемый типа ответа:</p>
        <ul>
            <li><code>""</code> (по умолчанию) – строка,</li>
            <li><code>"text"</code> – строка,</li>
            <li><code>"arraybuffer"</code> – ArrayBuffer (для бинарных данных, смотрите в <a
                    href="../8Бинарные данные и файлы/arraybuffer-binary-arrays.html">ArrayBuffer</a>, бинарные
                массивы),</li>
            <li><code>"blob"</code> – Blob (для бинарных данных, смотрите в <a
                    href="../8Бинарные данные и файлы/blob.html">Blob</a>),</li>
            <li><code>"document"</code> – XML-документ (может использовать XPath и другие XML-методы),</li>
            <li><code>"json"</code> – JSON (парсится автоматически). </li>
        </ul>
        <p>Например:</p>
        <pre><input type="button" value="Тестировать ответ" onclick="expl1()"><code class="language-js">
let xhr = new XMLHttpRequest();

xhr.open('GET', './example.json');

xhr.responseType = 'json';

xhr.send();

// тело ответа {"message": "Привет, мир!"}
xhr.onload = function() {
  let responseObj = xhr.response;
  alert(responseObj.message); // Привет, мир!
};              
        </code></pre>
        <script>
            function expl1() {
                let xhr = new XMLHttpRequest();

                xhr.open('GET', './example.json');

                xhr.responseType = 'json';

                xhr.send();

                // тело ответа {"message": "Привет, мир!"}
                xhr.onload = function () {
                    let responseObj = xhr.response;
                    alert(responseObj.message); // Привет, мир!
                };
            }
        </script>

    </div>
    <div class="topic" id="req">
        <h3>Состояния запроса</h3>
        <p><code>xhr.readyState</code> может быть:</p>
        <pre><code class="language-js">
UNSENT = 0; // исходное состояние
OPENED = 1; // вызван метод open
HEADERS_RECEIVED = 2; // получены заголовки ответа
LOADING = 3; // ответ в процессе передачи (данные частично получены)
DONE = 4; // запрос завершён            
        </code></pre>
        <p>Состояние меняется последовательно с тем нюансом, что 3 появляется до тех пор пока не получены все данные.
            Изменения в состоянии объекта запроса генерируют событие <code>readystatechange</code>:</p>
        <pre><code class="language-js">
xhr.onreadystatechange = function() {
  if (xhr.readyState == 3) {
    // загрузка
  }
  if (xhr.readyState == 4) {
    // запрос завершён
  }
};                
            </code></pre>
        <p>Однако при наличии событий: <code>load/error/progress</code> можно сказать что получение каких-то цифровых
            кодов состояния в стиле <code>C</code> - морально устарело.</p>
    </div>
    <div class="topic" id="cansel">
        <h3>Отмена запроса</h3>
        <pre><code class="language-js">
xhr.abort(); // завершить запрос            
        </code></pre>
        <p>При этом генерируется событие <code>abort</code>, а <code>xhr.status</code> устанавливается в 0.</p>
    </div>
    <div class="topic" id="sync">
        <h3>Синхронные запросы</h3>
        <p>Если третий параметр <code>false</code> то запрос выполняется синхронно:</p>
        <pre><code class="language-js">
let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
  xhr.send();
  if (xhr.status != 200) {
    alert(`Ошибка ${xhr.status}: ${xhr.statusText}`);
  } else {
    alert(xhr.response);
  }
} catch(err) { // для отлова ошибок используем конструкцию try...catch вместо onerror
  alert("Запрос не удался");
}            
        </code></pre>
        <p>Однако при этом блокируется выполнение нижеследующего кода и страница может выглядеть зависшей при долгой
            загрузке. А потому используется редко.</p>
    </div>
    <div class="topic" id="headers">
        <h3>HTTP-заголовки</h3>
        <p>3 метода для работы с заголовками:</p>
        <p><code>setRequestHeader(name, value)</code> - Устанавливает заголовок запроса с именем <code>name</code> и
            значением <code>value</code>.</p>
        <pre><code class="language-js">
xhr.setRequestHeader('Content-Type', 'application/json');            
        </code></pre>
        <p>Соотвественно есть ряд ограничений - некоторые заголовки невозможно установить, и повторные вызовы по типу:
        </p>
        <pre><code class="language-js">
xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// заголовок получится такой:
// X-Auth: 123, 456            
        </code></pre>
        <p>Будут приводить лишь к добавлению информации.</p>
        <p><code>getResponseHeader(name)</code> Возвращает значение заголовка ответа name (кроме Set-Cookie и
            Set-Cookie2).</p>
        <pre><code class="language-js">
xhr.getResponseHeader('Content-Type')            
        </code></pre>
        <p><code>getAllResponseHeaders()</code> Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2 в виде
            единой строки</p>
        <pre><code class="language-js">
Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT            
        </code></pre>
        <p>Между заголовками всегда стоит перевод строки в два символа <code>"\r\n"</code> вне зависимости от
            используемой ОС. </p>
    </div>
    <div class="topic" id="post">
        <h3>POST, FormData</h3>
        <p>Методика работы с объектом <code>FormData</code>:</p>
        <pre><code class="language-js">
&lt;form name="person"&gt;
  &lt;input name="name" value="Петя"&gt;
  &lt;input name="surname" value="Васечкин"&gt;
&lt;/form&gt;

&lt;script&gt;
  // заполним FormData данными из формы
  let formData = new FormData(document.forms.person);

  // добавим ещё одно поле
  formData.append("middle", "Иванович");

  // отправим данные
  let xhr = new XMLHttpRequest();
  xhr.open("POST", "/article/xmlhttprequest/post/user");
  xhr.send(formData);

  xhr.onload = () => alert(xhr.response);
&lt;/script&gt;            
        </code></pre>
        <p>Это отправка в кодировке <code>multipart/form-data</code>.</p>
        <p>Если нужна отправка в JSON то устанавливается соотвутствующий header:</p>
        <pre><code class="lang">
let xhr = new XMLHttpRequest();

let json = JSON.stringify({
  name: "Вася",
  surname: "Петров"
});

xhr.open("POST", '/submit')
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.send(json);            
        </code></pre>
        <p><code>.send(anythin)</code> отправляет что угодно, главное указать правильный заголовок.</p>
    </div>
    <div class="topic" id="progress">
        <h3>Прогресс отправки</h3>
        <p>Событие progress срабатывает только на стадии загрузки ответа с сервера.</p>
        <p>
            Существует другой объект, без методов, только для отслеживания событий отправки: xhr.upload.

            Он генерирует события, похожие на события xhr, но только во время отправки данных на сервер:
        </p>
        <ul>
            <li><code>loadstart</code> – начало загрузки данных.</li>
            <li><code>progress</code> – генерируется периодически во время отправки на сервер.</li>
            <li><code>abort</code> – загрузка прервана.</li>
            <li><code>error</code> – ошибка, не связанная с HTTP.</li>
            <li><code>load</code> – загрузка успешно завершена.</li>
            <li><code>timeout</code> – вышло время, отведённое на загрузку (при установленном свойстве timeout).</li>
            <li><code>loadend</code> – загрузка завершена, вне зависимости от того, как – успешно или нет. </li>
        </ul>
        <p>Пример:</p>
        <pre><code class="lang">
xhr.upload.onprogress = function(event) {
  alert(`Отправлено ${event.loaded} из ${event.total} байт`);
};

xhr.upload.onload = function() {
  alert(`Данные успешно отправлены.`);
};

xhr.upload.onerror = function() {
  alert(`Произошла ошибка во время отправки: ${xhr.status}`);            
        </code></pre>
        <p>Или чуть более расширенный пример с HTML:</p>
        <pre><code class="lang">
&lt;input type="file" onchange="upload(this.files[0])"&gt;

&lt;script&gt;
function upload(file) {
  let xhr = new XMLHttpRequest();

  // отслеживаем процесс отправки
  xhr.upload.onprogress = function(event) {
    console.log(`Отправлено ${event.loaded} из ${event.total}`);
  };

  // Ждём завершения: неважно, успешного или нет
  xhr.onloadend = function() {
    if (xhr.status == 200) {
      console.log("Успех");
    } else {
      console.log("Ошибка " + this.status);
    }
  };

  xhr.open("POST", "/article/xmlhttprequest/post/upload");
  xhr.send(file);
}
&lt;/script&gt;            
        </code></pre>
    </div>
    <div class="topic" id="cors">
        <h3>Запросы на другой источник</h3>
        <p>Такая же херабора как и в fetch</p>
    </div>
    <div class="topic" id="total">
        <h3><a href="https://learn.javascript.ru/xmlhttprequest#itogo">Итого</a></h3>
        <p>Просто ссылкой. Смысла расписывать нет.</p>
    </div>
</body>

</html>