<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IndexedDB</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#indexeddb">IndexedDB</a></h2>
        <ul>
            <li><a href="#open">Открыть базу данных</a></li>
            <li><a href="#wharehouse">Хранилище объектов</a></li>
            <li><a href="#transact">Транзакции</a></li>
            <li><a href="#auto">Автоматическая фиксация транзакций</a></li>
            <li><a href="#errors">Обработка ошибок</a></li>
            <li><a href="#keys">Поиск по ключам</a></li>
            <li><a href="#index">Поиск по индексированному полю</a></li>
            <li><a href="#delete">Удаление из хранилища</a></li>
            <li><a href="#cursors">Курсоры</a></li>
            <li><a href="#include">Обёртка для промисов</a></li>
            <li><a href="#total">Итого</a></li>
        </ul>
    </div>

    <div class="topic" id="indexeddb">
        <h2><a href="https://learn.javascript.ru/indexeddb">IndexedDB</a></h2>
        <p>IndexedDB – это встроенная база данных, которая:</p>
        <ul>
            <li>Хранит практически любые значения по ключам, несколько типов ключей</li>
            <li>Поддерживает транзакции для надёжности.</li>
            <li>Поддерживает запросы в диапазоне ключей и индексы.</li>
            <li>Позволяет хранить больше данных, чем <code>localStorage</code>. </li>
        </ul>
        <p>Работает на событиях, но есть обёртки на промисах например https://github.com/jakearchibald/idb</p>
    </div>

    <div class="topic" id="open">
        <h3>Открыть базу данных</h3>
        <pre><code class="language-js">
let openRequest = indexedDB.open(name, version);            
        </code></pre>
        <p>Где:</p>
        <ul>
            <li><code>name</code> – название базы данных, строка.</li>
            <li><code>version</code> – версия базы данных, положительное целое число, по умолчанию 1 (объясняется ниже).
            </li>
        </ul>
        <p>Доступ к бд осуществляется по политике одного источка. После создания бд необходимо назначить обработчики
            событий для объекта <code>openRequest</code>:</p>
        <ul>
            <li><code>success</code>: база данных готова к работе, готов «объект базы данных» openRequest.result, его
                следует использовать для дальнейших вызовов.</li>
            <li><code>error</code>: не удалось открыть базу данных.</li>
            <li><code>upgradeneeded</code>: база открыта, но её схема устарела (см. ниже). </li>
        </ul>
        <p><strong>IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах
                данных.</strong></p>
        <p>База данных работает в браузере и и прямого доступа к данным нет, однако когда база данных публикуется и
            версия меньше чем текущая то может потребоваться обновить БД и сработает специальное событие
            <code>upgradeneeded</code>.
        </p>
        <pre><code class="language-js">
let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {
  // срабатывает, если на клиенте нет базы данных
  // ...выполнить инициализацию...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // продолжить работу с базой данных, используя объект db
};                
            </code></pre>
        <p>Допустим дальше мы инициализируем 2 версию:</p>
        <pre><code class="language-js">
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function(event) {
  // версия существующей базы данных меньше 2 (или база данных не существует)
  let db = openRequest.result;
  switch(event.oldVersion) { // существующая (старая) версия базы данных
    case 0:
      // версия 0 означает, что на клиенте нет базы данных
      // выполнить инициализацию
    case 1:
      // на клиенте версия базы данных 1
      // обновить
  }
};                
            </code></pre>
        <p>Удаление БД</p>
        <pre><code class="language-js">
let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror отслеживает результат                
            </code></pre>
    </div>

    <div class="topic" id="wharehouse">
        <h3>Хранилище объектов</h3>
        <p>В БД можно хранить сложные объекты, используя связку ключ-значение. Ключ должен быть одним из следующих
            типов: number, date, string, binary или array. Это уникальный идентификатор: по ключу мы можем
            искать/удалять/обновлять значения. Синтаксис создания хранилища:</p>
        <pre><code class="language-js">
db.createObjectStore(name[, keyOptions]);                
            </code></pre>
        <p>Где:</p>
        <ul>
            <li><code>name</code> – это название хранилища, например "books" для книг,</li>
            <li><code>keyOptions</code> – это необязательный объект с одним или двумя свойствами:</li>
            <ul>
                <li><code>keyPath</code> – путь к свойству объекта, которое <code>IndexedDB</code> будет использовать в
                    качестве ключа, например
                    <code>id</code>.
                </li>
                <li><code>autoIncrement</code> – если <code>true</code>, то ключ будет формироваться автоматически для
                    новых объектов, как
                    постоянно увеличивающееся число. </li>
            </ul>
            <p>Например, это хранилище объектов использует свойство id как ключ:</p>
            <pre><code class="language-js">
db.createObjectStore('books', {keyPath: 'id'});                
            </code></pre>
            <p><strong>Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в
                    обработчике upgradeneeded.</strong></p>
            <p>Для обновления версии базы есть два основных подхода:</p>
            <ol>
                <li>Мы можем реализовать функции обновления по версиям: с 1 на 2, с 2 на 3 и т.д. Потом в upgradeneeded
                    сравнить версии (например, была 2, сейчас 4) и запустить операции обновления для каждой
                    промежуточной версии (2 на 3, затем 3 на 4).</li>
                <li>Или мы можем взять список существующих хранилищ объектов, используя db.objectStoreNames. Этот объект
                    является DOMStringList, в нём есть метод contains(name), используя который можно проверить
                    существование хранилища. Посмотреть, какие хранилища есть и создать те, которых нет. </li>
            </ol>
        </ul>
        <p>Для простых баз данных второй подход может быть проще и предпочтительнее.

            Вот демонстрация второго способа:</p>
        <pre><code class="language-js">
let openRequest = indexedDB.open("db", 2);

// создаём хранилище объектов для books, если ешё не существует
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // если хранилище "books" не существует
    db.createObjectStore('books', {keyPath: 'id'}); // создаём хранилище
  }
};            
        </code></pre>
        <p>Для удаления хранилища объектов:</p>
        <pre><code class="language-js">
db.deleteObjectStore('books')    
</code></pre>

    </div>

    <div class="topic" id="transact">
        <h3>Транзакции</h3>
        <p>Работа с БД организована на уровне транзакций - автомарных операций. Для начала транзакции:</p>
        <pre><code class="language-js">
db.transaction(store[, type]);            
        </code></pre>
        <p>Где:</p>
        <ul>
            <li>store – это название хранилища, к которому транзакция получит доступ, например, "books". Может быть
                массивом названий, если нам нужно предоставить доступ к нескольким хранилищам.</li>
            <li>type – тип транзакции, один из:</li>
            <ul>
                <li>readonly – только чтение, по умолчанию.</li>
                <li>readwrite – только чтение и запись данных, создание/удаление самих хранилищ объектов недоступно.
                </li>
            </ul>
        </ul>
        <p>Например:</p>
        <pre><code class="language-js">
let transaction = db.transaction("books", "readwrite"); // (1)

// получить хранилище объектов для работы с ним
let books = transaction.objectStore("books"); // (2)

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
  console.log("Книга добавлена в хранилище", request.result);
};

request.onerror = function() {
  console.log("Ошибка", request.error);
};            
        </code></pre>
        <p>
            Хранилища объектов поддерживают два метода для добавления значений:
        </p>
        <ol>
            <li><code>put(value, [key])</code> Добавляет значение value в хранилище. Ключ key необходимо указать, если
                при создании
                хранилища объектов не было указано свойство keyPath или autoIncrement. Если уже есть значение с таким же
                ключом, то оно будет заменено.</li>

            <li><code>add(value, [key])</code> То же, что put, но если уже существует значение с таким ключом, то запрос
                не
                выполнится, будет сгенерирована ошибка с названием "ConstraintError" </li>
        </ol>
        <p>Аналогично открытию базы, мы отправляем запрос: books.add(book) и после ожидаем события success/error.</p>
        <ul>
            <li>request.result для add является ключом нового объекта.</li>
            <li>Ошибка находится в request.error (если есть).</li>
        </ul>
    </div>






</body>

</html>