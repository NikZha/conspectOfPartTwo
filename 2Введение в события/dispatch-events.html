<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генерация пользовательских событий</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
    <div class="contents">
        <h2><a href="#dispatch">Генерация пользовательских событий</a></h2>
        <ul>
            <li><a href="#event">Конструктор Event</a></li>
            <li><a href="#dispatchEvent">Метод dispatchEvent</a></li>
            <li><a href="#example">Пример всплытия</a></li>
            <li><a href="#mouseevent">MouseEvent, KeyboardEvent и другие</a></li>
            <li><a href="#usersevents">Пользовательские события</a></li>
            <li><a href="#eventpreventdefault">event.preventDefault()</a></li>
            <li><a href="#into">Вложенные события обрабатываются синхронно</a></li>
            <li><a href="#total">Итого</a></li>
        </ul>
    </div>
    <div class="topic" id="dispatch">
        <h2><a href="https://learn.javascript.ru/dispatch-events">Генерация пользовательских событий</a></h2>
        <p>События можно генерировать из JavaScript кода, этому и будет посвящена эта глава. Причём события могут быть
            как стандартные, так и самописные.</p>
    </div>
    <div class="topic" id="event">
        <h3>Конструктор Event</h3>
        <p>Событие встроенного класса Event можно создать так:</p>
        <pre><code class="language-js">
let event = new Event(type[, options]);        
    </code></pre>
        <p>Где:</p>
        <ul>
            <li><code>type</code> – тип события, строка, например "click" или же любой придуманный нами – "my-event".
            </li>
            <li><code>options</code> – объект с тремя необязательными свойствами:
                <ul>
                    <li><code>bubbles: true/false</code> – если true, тогда событие всплывает.
                    </li>
                    <li><code>cancelable: true/false</code> – если true, тогда можно отменить действие по умолчанию.
                        Позже мы разберём, что это значит для пользовательских событий.</li>
                    <li><code>composed: true/false</code> – если true, тогда событие будет всплывать наружу за пределы
                        Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.</li>
                </ul>
            </li>
        </ul>
        <p>По умолчанию все три свойства установлены в
            <code>false: {bubbles: false, cancelable: false, composed: false}.</code>

        </p>
    </div>
    <div class="topic" id="dispatchEvent">
        <h3>Метод dispatchEvent</h3>
        <p>После того, как объект события создан, мы должны запустить его на элементе, вызвав метод
            <code>elem.dispatchEvent(event)</code>.
        </p>
        <pre><code class="language-js">
&lt;button id="elem" onclick="alert('Клик!');">Автоклик&lt;/button>

&lt;script>
  let event = new Event("click");
  elem.dispatchEvent(event);
&lt;/script>        
    </code></pre>
        <blockquote>
            <h4>event.isTrusted</h4>
            <p>Свойство event.isTrusted принимает значение true для событий, порождаемых реальными действиями
                пользователя, и false для генерируемых кодом.</p>
        </blockquote>
    </div>
    <div class="topic" id="example">
        <h3>Пример всплытия</h3>
        <pre><code class="language-js">
&lt;h1 id="elem">Привет из кода!&lt;/h1>

&lt;script>
  // ловим на document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Привет от " + event.target.tagName); // Привет от H1
  });

  // ...запуск события на элементе!
  let event = new Event("hello", {bubbles: true}); // (2)
  elem.dispatchEvent(event);

  // обработчик на document сработает и выведет сообщение.

&lt;/script>        
    </code></pre>
        <p>Два нюанса этого кода:
        <ol>
            <li>Мы должны использовать addEventListener для наших собственных событий, т.к. on<event>-свойства
                    существуют только для встроенных событий, то есть document.onhello не сработает.</li>
            <li>Мы обязаны передать флаг bubbles:true, иначе наше событие не будет всплывать. </li>
        </ol>
        Механизм всплытия идентичен как для встроенного события (click), так и для пользовательского события (hello).
        Также одинакова работа фаз всплытия и погружения.
        </p>
    </div>
    <div class="topic" id="mouseevent">
        <h3>MouseEvent, KeyboardEvent и другие</h3>
        <p><a href="https://www.w3.org/TR/uievents">Сперцификация на event'ы</a> есть следующие конструкторы:</p>
        <ul>
            <li>UIEvent</li>
            <li>FocusEvent</li>
            <li>MouseEvent</li>
            <li>WheelEvent</li>
            <li>KeyboardEvent</li>
            <li>…</li>
        </ul>
        <p>Которые принимают в себя объекты:</p>
        <pre><code class="language-js">
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});        
    </code></pre>
        <p>Эти события хоть и являются специфичными, но можно и устаналивать свойства напрямую:
            event.clientX=100. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые
            генерирует браузер, всегда имеют правильный тип.
        </p>
        <p>Далее автор отсылает к <a href="https://www.w3.org/TR/uievents/#mouseevent">спецификации</a></p>
    </div>
    <div class="topic" id="usersevents">
        <h3>Пользовательские события</h3>
        <p>Для генерации подобных событий следует использовать конструктор <code>new CustomEvent</code> который
            идентичен конструктору <code>new Event</code>, но в нём есть доп свойство detail, как пример:</p>
        <pre><code class="language-js">
&lt;h1 id="elem">Привет для Васи!&lt;/h1>

&lt;script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
&lt;/script>                
            </code></pre>
        <p>Это свойство служит для описания события, хотя туда можно пихать любые данные.</p>
    </div>
    <div class="topic" id="eventpreventdefault">
        <h3>event.preventDefault()</h3>
        <p>event.preventDefault() может отменить обработку пользовательского события если оно создано с
            <code>cancelable: true</code>
        </p>
        <div id="hide">
            <pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
            <button onclick="hide()">Hide()</button>

            <script>
                // hide() будет вызван при щелчке на кнопке
                function hide() {
                    let event = new CustomEvent("hide", {
                        cancelable: true // без этого флага preventDefault не сработает
                    });
                    if (!rabbit.dispatchEvent(event)) {
                        alert('Действие отменено обработчиком');
                    } else {
                        rabbit.hidden = true;
                    }
                }

                rabbit.addEventListener('hide', function (event) {
                    if (confirm("Вызвать preventDefault?")) {
                        event.preventDefault();
                    }
                });
            </script>
        </div>
        <pre><code class="language-js">
&lt;pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
&lt;/pre>
&lt;button onclick="hide()">Hide()&lt;/button>

&lt;script>
  // hide() будет вызван при щелчке на кнопке
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // без этого флага preventDefault не сработает
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('Действие отменено обработчиком');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("Вызвать preventDefault?")) {
      event.preventDefault();
    }
  });
&lt;/script>        
    </code></pre>
        <p>Здесь вызов elem.dispatchEvent(event) возвратит false. И код, сгенерировавший событие, узнает, что продолжать
            не нужно.</p>
    </div>
    <div class="topic" id="into">
        <h3>Вложенные события обрабатываются синхронно</h3>
        <p>Обычно события обрабатываются асинхронно. То есть, если браузер обрабатывает onclick и в процессе этого
            произойдёт новое событие, то оно ждёт, пока закончится обработка onclick.</p>

        <p>Исключением является ситуация, когда событие инициировано из обработчика другого события.</p>

        <p>Тогда управление сначала переходит в обработчик вложенного события и уже после этого возвращается назад.</p>

        <p>В примере ниже событие menu-open обрабатывается синхронно во время обработки onclick: </p>
        <pre><code class="language-js">
&lt;button id="menu">Меню (нажми меня)&lt;/button>

&lt;script>
  menu.onclick = function() {
    alert(1);

    // alert("вложенное событие")
    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
&lt;/script>            
        </code></pre>
        <div>
            <button id="menu">Меню (нажми меня)</button>

            <script>
                menu.onclick = function () {
                    alert(1);

                    // alert("вложенное событие")
                    menu.dispatchEvent(new CustomEvent("menu-open", {
                        bubbles: true
                    }));

                    alert(2);
                };

                document.addEventListener('menu-open', () => alert('вложенное событие'))
            </script>
        </div>
        <p>Порядок вывода: 1 → вложенное событие → 2.

        </p>
        <p>Если нам это не подходит, то мы можем либо поместить dispatchEvent (или любой другой код, инициирующий
            события) в конец обработчика onclick, либо, если это неудобно, можно обернуть генерацию события в setTimeout
            с нулевой задержкой:</p>
        <pre><code class="language-js">
&lt;button id="menu">Меню (нажми меня)&lt;/button>

&lt;script>
  menu.onclick = function() {
    alert(1);

    // alert(2)
    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
&lt;/script>                
            </code></pre>
        <div>
            <button id="menu1">Меню (нажми меня)</button>

            <script>
                menu1.onclick = function () {
                    alert(1);

                    // alert(2)
                    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open1", {
                        bubbles: true
                    })));

                    alert(2);
                };

                document.addEventListener('menu-open1', () => alert('вложенное событие'))
            </script>
        </div>
        <p>Теперь dispatchEvent запускается асинхронно после исполнения текущего кода, включая menu.onclick, поэтому
            обработчики полностью независимы.</p>

        <p>Новый порядок вывода: 1 → 2 → вложенное событие. </p>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>let event = new Event(type[, options]); опиции означены <a href="#event">тут</a>.</p>
        <p>Метод elem.dispatchEvent(event) вешает на элемент событие, как если бы его инициализации извне, например
            пользователь. а event.isTrusted
            сообщает было ли событие иницаилизировано пользователем или из кода.</p>
        <p>Сущетствует множество евентов которые принимают объекты со свойствами события.</p>
        <p>Пользовательские события создаются при помощи <code> new CustomEvent</code> и имеют доп свойство
            <code>detail</code>, которое принимает произвольный объект описания события</p>
            <p>event.preventDefault() может отменить обработку пользовательского события если оно создано с cancelable: true
вызов elem.dispatchEvent(event) возвратит false. И код, сгенерировавший событие, узнает, что продолжать не нужно.
</p>
<p>Чтобы обойти синхронность обработки вложенных событий используют setTimeout без времени. </p>
    </div>
</body>

</html>