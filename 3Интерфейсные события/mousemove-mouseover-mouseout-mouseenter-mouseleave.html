<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Движение мыши: mouseover/out, mouseenter/leave</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
    <div class="contents">
        <h2><a href="#mouse">Движение мыши: mouseover/out, mouseenter/leave</a></h2>
        <ul>
            <li><a href="#mouseover">События mouseover/mouseout, relatedTarget</a></li>
            <li><a href="#pass">Пропуск элементов</a></li>
            <li><a href="#mouseout">Событие mouseout при переходе на потомка</a></li>
            <li><a href="#mouseenter">События mouseenter и mouseleave</a></li>
            <li><a href="#delegation">Делегирование событий</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задачи</a></li>
        </ul>
    </div>
    <div class="topic" id="mouse">
        <h2><a href="https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave">Движение мыши:
                mouseover/out, mouseenter/leave</a></h2>
        <p>В этой главе мы более подробно рассмотрим события, возникающие при движении указателя мыши над элементами
            страницы.</p>
    </div>
    <div class="topic" id="mouseover">
        <h3>События mouseover/mouseout, relatedTarget</h3>
        <p>Событие mouseover происходит в момент, когда курсор оказывается над элементом, а событие mouseout – в момент,
            когда курсор уходит с элемента.</p>
        <p>
            Эти события являются особенными, потому что у них имеется свойство relatedTarget. Оно «дополняет» target.
            Когда мышь переходит с одного элемента на другой, то один из них будет target, а другой relatedTarget.

            Для события mouseover:
        <ul>
            <li><code>event.target</code> – это элемент, на который курсор перешёл.</li>
            <li><code>event.relatedTarget</code> – это элемент, с которого курсор ушёл (relatedTarget → target). </li>
        </ul>
        </p>
        <p>Для события <code>mouseout</code> будет соотвественно наоборот:
        <ul>
            <li><code>event.target</code> – это элемент, с которого курсор ушёл.</li>
            <li><code>event.relatedTarget</code> – это элемент, на который курсор перешёл (target → relatedTarget).
            </li>
        </ul>
        </p>
        <blockquote>
            <h4>relatedTarget может быть null</h4>
            Курсор может уйти за пределы окна, и прийти из-за пределов окна.
        </blockquote>
    </div>
    <div class="topic" id="pass">
        <h3>Пропуск элементов</h3>
        <p>Событие mousemove происходит при движении мыши. Однако, это не означает, что указанное событие генерируется
            при прохождении каждого пикселя.</p>
        <p>Элементы могут пропускаться если указатель мыши двигается быстро. В таком случае <code>relatedTarget</code>
            может быть null. И на пропущенных элементах не сгенерируется никаких событий.</p>
        <blockquote>
            <h4>Если был mouseover, то будет и mouseout</h4>
            Несмотря на то, что при быстрых переходах промежуточные элементы могут игнорироваться, в одном мы можем быть
            уверены: элемент может быть пропущен только целиком.

            Если указатель «официально» зашёл на элемент, то есть было событие mouseover, то при выходе с него
            обязательно будет mouseout.
        </blockquote>
    </div>
    <div class="topic" id="mouseout">
        <h3>Событие mouseout при переходе на потомка</h3>
        <p>Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на
            его потомка.</p>
        <p>Событие mouseover, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой
            обработчик, то оно его вызовет. При переходе с родителя элемента на потомка – на родителе сработают два
            обработчика: и mouseout и mouseover:</p>
        <pre>
                <code class="language-js">
parent.onmouseout = function(event) {
  /* event.target: внешний элемент */
};
parent.onmouseover = function(event) {
  /* event.target: внутренний элемент (всплыло) */
};                      
                </code>
            </pre>
        <p>Если код внутри обработчиков не смотрит на target, то он подумает, что мышь ушла с элемента parent и
            вернулась на него обратно. Но это не так! Мышь никуда не уходила, она просто перешла на потомка.</p>

        <p>Если при уходе с элемента что-то происходит, например, запускается анимация, то такая интерпретация
            происходящего может давать нежелательные побочные эффекты.</p>

        <p>Чтобы этого избежать, можно смотреть на relatedTarget и, если мышь всё ещё внутри элемента, то игнорировать
            такие события.</p>

        <p>Или же можно использовать другие события: mouseenter и mouseleave, которые мы сейчас изучим, с ними такая
            проблема не возникает. </p>
    </div>
    <div class="topic" id="mouseenter">
        <h3>События mouseenter и mouseleave</h3>
        <p>Отличия <code>mouseenter/mouseleave</code> от <code>mouseover/mouseout</code>:</p>
        <ol>
            <li>Переходы внутри элемента, на его потомки и с них, не считаются.</li>
            <li>События mouseenter/mouseleave не всплывают. </li>
        </ol>
        <p>Когда указатель появляется над элементом – генерируется mouseenter, причём не имеет значения, где именно
            указатель: на самом элементе или на его потомке.</p>

        <p>Событие mouseleave происходит, когда курсор покидает элемент.</p>
    </div>
    <div class="topic" id="delegation">
        <h3>Делегирование событий</h3>
        <p>Так как события mouseenter/leave не высплывают их. Поэтому автор предлагает использовать
            <code>mouseover/mouseout.</code> И привязывать их конкретным элементам.
            В основном привязывание достигается проверками вида:
        <pre><code class="language-js">
  let target = event.target.closest('td');

  // переход не на <td> - игнорировать
  if (!target) return;

  // переход на <td>, но вне нашей таблицы (возможно при вложенных таблицах)
  // игнорировать
  if (!table.contains(target)) return;
        </code></pre>
        Так же надо осуществлять проверку родительского элемента, полный код находится тут:
        <pre><code class="language-js">
// ячейка <td> под курсором в данный момент (если есть)
let currentElem = null;

table.onmouseover = function(event) {
  // перед тем, как войти на следующий элемент, курсор всегда покидает предыдущий
  // если currentElem есть, то мы ещё не ушли с предыдущего <td>,
  // это переход внутри - игнорируем такое событие
  if (currentElem) return;

  let target = event.target.closest('td');

  // переход не на <td> - игнорировать
  if (!target) return;

  // переход на <td>, но вне нашей таблицы (возможно при вложенных таблицах)
  // игнорировать
  if (!table.contains(target)) return;

  // ура, мы зашли на новый <td>
  currentElem = target;
  target.style.background = 'pink';
};


table.onmouseout = function(event) {
  // если мы вне <td>, то игнорируем уход мыши
  // это какой-то переход внутри таблицы, но вне <td>,
  // например с <tr> на другой <tr>
  if (!currentElem) return;

  // мы покидаем элемент – но куда? Возможно, на потомка?
  let relatedTarget = event.relatedTarget;

  while (relatedTarget) {
    // поднимаемся по дереву элементов и проверяем – внутри ли мы currentElem или нет
    // если да, то это переход внутри элемента – игнорируем
    if (relatedTarget == currentElem) return;

    relatedTarget = relatedTarget.parentNode;
  }

  // мы действительно покинули элемент
  currentElem.style.background = '';
  currentElem = null;
};            
        </code></pre>
        На этом примере была решена первая задача.
        </p>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        Особенности, на которые стоит обратить внимание:
        <ul>
            <li>При быстром движении мыши события не будут возникать на промежуточных элементах.</li>
            <li>События mouseover/out и mouseenter/leave имеют дополнительное свойство: relatedTarget. Оно дополняет
                свойство target и содержит ссылку на элемент, с/на который мы переходим.</li>
        </ul>
        <p>События mouseover/out возникают, даже когда происходит переход с родительского элемента на потомка. С точки
            зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым
            глубоко вложенным.</p>

        <p>События mouseenter/leave в этом отличаются. Они генерируются, когда курсор переходит на элемент в целом или
            уходит с него. Также они не всплывают. </p>
    </div>
    <div class="topic" id="tasks">
        <h3>Задачи</h3>
        <div id="task1">
            <h4>Задача 1</h4>
            <iframe src="mousemoveTask1.html" frameborder="0" style="width: 800; height: 800;"></iframe>
            <p>Не решено показ, как в примере на сайте учебника, над и под домиком. И почему-то не удаётся установить
                размеры, с показом подсказки.</p>

        </div>
    </div>










</body>

</html>