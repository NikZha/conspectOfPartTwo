<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Введение в браузерные события</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body>
    <div class="contents">
        <h2><a href="#introduction">Введение в браузерные события</a></h2>
        <ul>
            <li><a href="#handlers">Обработчики событий</a></li>
            <li><a href="#this">Доступ к элементу через this</a></li>
            <li><a href="#often">Частые ошибки</a></li>
            <li><a href="#addEventListener">addEventListener</a></li>
            <li><a href="#obj">Объект события</a></li>
            <li><a href="#handleEvent">Объект-обработчик: handleEvent</a></li>
            <li><a href="#total">Итого</a></li>
            <li><a href="#tasks">Задачи</a></li>
        </ul>
    </div>
    <div class="topic" id="introduction">
        <h2><a href="https://learn.javascript.ru/introduction-browser-events">Введение в браузерные события</a></h2>
        <p>Самые используемые события:</p>
        <p>События мыши (c прибавкой on(click) и тд):
        <ul>
            <li>click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами
                оно происходит при касании).</li>
            <li>contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.</li>
            <li>mouseover / mouseout – когда мышь наводится на / покидает элемент.</li>
            <li>mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.</li>
            <li>mousemove – при движении мыши.</li>
        </ul>

        </p>
        <p>
            События на элементах управления:
        <ul>
            <li>submit – пользователь отправил форму &lt;form>.</li>
            <li>focus – пользователь фокусируется на элементе, например нажимает на &lt;input>.</li>
        </ul>
        </p>
        <p>
            Клавиатурные события:

        <ul>
            <li>keydown и keyup – когда пользователь нажимает / отпускает клавишу. </li>
        </ul>
        </p>
        <p>
            События документа:

        <ul>
            <li>DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.</li>
        </ul>
        CSS events:

        <ul>
            <li>transitionend – когда CSS-анимация завершена. </li>
        </ul>
        Так же есть и другие события.
        </p>
    </div>
    <div class="topic" id="handlers">
        <h3>Обработчики событий</h3>
        <p>Есть способы назначить обработчики событий:</p>
        <div id="useatribute">
            <h4>Использование атрибута HTML</h4>
            <p>Самый просто и часто используемый по ходу ведения конспекта:
            <pre>
    <code class="language-js">
input value="Нажми меня" onclick="alert('Клик!')" type="button"        
    </code>
</pre>

            </p>
        </div>
        <div id="dom">
            <h4>Использование свойства DOM-объекта</h4>
            <p>Практически тоже с другого края, то есть использование свойств объекта, а не прописывание в html-элементе
                атрибута:
            <pre>
    <code class="language-js">
&lt;input id="elem" type="button" value="Нажми меня!">
&lt;script>
  elem.onclick = function() {
    alert('Спасибо');
  };
&lt;/script>        
    </code>
</pre>
            <strong>Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его
                инициализации.</strong>
            </p>
            <p><strong>Так как у элемента DOM может быть только одно свойство с именем onclick, то назначить более
                    одного обработчика так нельзя.</strong></p>
            <p>Назначить обработчик можно и так:
            <pre>
                    <code class="language-js">
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;                        
                    </code>
                </pre>
            Убрать обработчик можно назначением <code class="language-js">elem.onclick = null</code>.
            </p>
        </div>
    </div>
    <div class="topic" id="this">
        <h3>Доступ к элементу через this</h3>
        <p>Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как говорят,
            «висит» (т.е. назначен) обработчик. То есть this внутри элемента ссылается на сам элемент.
        <pre><button onclick="alert(this.innerHTML)">Нажми меня</button>
    <code class="language-js">
&lt;button onclick="alert(this.innerHTML)">Нажми меня&lt;/button>        
    </code>
</pre>
        </p>
    </div>
    <div class="topic" id="often">
        <h3>Частые ошибки</h3>
        <p><strong>Присваивание без скобок:</strong>
        <pre>
        <code class="language-js">
// правильно
button.onclick = sayThanks;

// неправильно
button.onclick = sayThanks();            
        </code>
    </pre>
        </p>
        <p><strong>Используйте именно функции, а не строки.</strong>
            <br>Так делать <code>elem.onclick = "alert(1)"</code> не рекомендуется. Но я так очень часто делаю в
            конспекте для
            экономии времени и места.
        </p>
        <p><strong>Не используйте setAttribute для обработчиков.</strong> <br>Не сработает:
        <pre>
            <code class="language-js">
// при нажатии на body будут ошибки,
// атрибуты всегда строки, и функция станет строкой
document.body.setAttribute('onclick', function() { alert(1) });                
            </code>
        </pre>
        </p>
        <p><strong>Регистр DOM-свойства имеет значение.</strong><br>Используйте elem.onclick, а не elem.ONCLICK, потому
            что DOM-свойства чувствительны к регистру.</p>
    </div>
    <div class="topic" id="addEventListener">
        <h3>addEventListener</h3>
        <p>Эта функция призвана преодолеть два узких места: назначение множественных обработчиков одному событию и
            функция задания обработчика свойству. Синтаксис:
        <pre>
    <code class="language-js">
element.addEventListener(event, handler, [options]);        
    </code>
</pre>
        Где: event - Имя события, например "click". handler Ссылка на функцию-обработчик, options
        Дополнительный объект со свойствами:
        <ul>
            <li>once: если true, тогда обработчик будет автоматически удалён после выполнения.</li>
            <li>capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе
                Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое,
                что {capture: false/true}.</li>
            <li>passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом
                будет рассказано в главе Действия браузера по умолчанию. </li>
        </ul>
        Для удаления обработчика следует использовать removeEventListener:
        <pre>
    <code class="language-js">
element.removeEventListener(event, handler, [options]);        
    </code>
</pre>

        </p>
        <blockquote>
            <h5>Удаление требует именно ту же функцию
            </h5>
            <p>Вот так не сработает:
            <pre>
    <code class="language-js">
elem.addEventListener( "click" , () => alert('Спасибо!'));
// ....
elem.removeEventListener( "click", () => alert('Спасибо!'));        
    </code>
</pre>
            Надо совать именно туже самую функцию, а это другие. Правильное использование:
            <pre>
    <code class="language-js">
function handler() {
  alert( 'Спасибо!' );
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);        
    </code>
</pre>
            </p>
        </blockquote>
        <p>Как уже было сказано, с помощью addEventListener можно добавлять несколько обработчиков на одно событие:
        <pre>
    <code class="language-js">
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!        
    </code>
</pre>
        <input id="elem" type="button" value="Нажми меня" />

        <script>
            function handler1() {
                alert('Спасибо!');
            };

            function handler2() {
                alert('Спасибо ещё раз!');
            }

            elem.onclick = () => alert("Привет");
            elem.addEventListener("click", handler1); // Спасибо!
            elem.addEventListener("click", handler2); // Спасибо ещё раз!
        </script>
        <br><em>Во избежании путаницы лучше использовать один метод для добавления обработчика.</em>
        </p>
        <blockquote>
            <h4>Обработчики некоторых событий можно назначать только через addEventListener</h4>
            Например:
            <pre>
    <code class="language-js">
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM построен"); // а вот так сработает
});        
    </code>
</pre>
            Так что addEventListener более универсален. Хотя заметим, что таких событий меньшинство, это скорее
            исключение, чем правило.
        </blockquote>
    </div>
    <div class="topic" id="obj">
        <h3>Объект события</h3>
        <input type="button" value="Нажми меня" id="elem1">

        <script>
            elem1.onclick = function (event) {
                // вывести тип события, элемент и координаты клика
                alert(event.type + " на " + event.currentTarget);
                alert("Координаты: " + event.clientX + ":" + event.clientY);
            };
        </script>
        <pre>
        <code class="language-js">
&lt;input type="button" value="Нажми меня" id="elem">

&lt;script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
&lt;/script>            
        </code>
    </pre>
        <p>То есть понятно, что событие это объект со своими свойствами:
            <br><code>event.type</code> - Тип события, в данном случае "click".
            <br><code>event.currentTarget</code> - Элемент, на котором сработал обработчик. Значение – обычно такое же,
            как и у this,
            но если обработчик
            является функцией-стрелкой или при помощи bind привязан другой объект в качестве this, то мы можем получить
            элемент из event.currentTarget.
            <br><code>event.clientX / event.clientY</code> - Координаты курсора в момент клика относительно окна, для
            событий мыши.

        </p>
        <p>Так же есть ряд других свойств.</p>
        <blockquote>
            <h4>Объект события доступен и в HTML</h4>
            <p>При назначении обработчика в HTML, тоже можно использовать объект event, вот так:</p>
            <input type="button" onclick="alert(event.type)" value="Тип события">
            <pre>
    <code class="language-js">
&lt;input type="button" onclick="alert(event.type)" value="Тип события">        
    </code>
</pre>
        </blockquote>
    </div>
    <div class="topic" id="handleEvent">
        <h3>Объект-обработчик: handleEvent</h3>
        <p>Собстенно handleEvent это метод в объекте который отвечает за обработку объекта события.
        <pre>
    <code class="language-js">
&lt;button id="elem">Нажми меня&lt;/button>

&lt;script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
&lt;/script>        
    </code>
</pre>
        <button id="elem2">Нажми меня</button>

        <script>
            elem2.addEventListener('click', {
                handleEvent(event) {
                    alert(event.type + " на " + event.currentTarget);
                }
            });
        </script>
        <br>Полноценная обработка в классе:
        <pre>
    <code class="language-js">
&lt;button id="elem">Нажми меня&lt;/button>

&lt;script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
&lt;/script>        
    </code>
</pre>
        Метод handleEvent не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые
        заточены под обработку конкретных типов событий, вот так:
        <pre>
            <code class="language-js">
&lt;button id="elem">Нажми меня&lt;/button>

&lt;script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method]();
    }

    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }

    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
&lt;/script>                
            </code>
        </pre>
        <button id="elemThree">Нажми меня</button>

        <script>
            class Menu {
                handleEvent(event) {
                    // mousedown -> onMousedown
                    let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
                    this[method]();
                }

                onMousedown() {
                    elemThree.innerHTML = "Кнопка мыши нажата";
                }

                onMouseup() {
                    elemThree.innerHTML += "...и отжата.";
                }
            }

            let menu = new Menu();
            elemThree.addEventListener('mousedown', menu);
            elemThree.addEventListener('mouseup', menu);
        </script>
        На примере говнокод - идёт обращение из метода класса непосредственно к переменной. Однако надо отметить, что
        пример здравый в части разделения вызова методов без ветвлений.
        </p>
    </div>
    <div class="topic" id="total">
        <h3>Итого</h3>
        <p>Есть три способа назначения обработчиков событий:
        <ol>
            <li>Атрибут HTML: onclick="...".</li>
            <li>DOM-свойство: elem.onclick = function.</li>
            <li>Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener
                для удаления. </li>
        </ol>
        </p>
        <p>HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много
            кода там не напишешь.</p>

        <p>DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип
            события. Во многих случаях с этим ограничением можно мириться.</p>

        <p>Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые
            работают только через него, например, DOMContentLoaded. Также addEventListener поддерживает объекты в
            качестве обработчиков событий. В этом случае вызывается метод объекта handleEvent.</p>

        <p>Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит
            подробности о том, что произошло.</p>
    </div>
    <div class="topic" id="tasks">
        <h3>Задачи</h3>
        <div id="task1">
            <h4>Задача 1</h4>
            <input type="button" value="Спрятать текст" onclick="task1(text)">
            <br>
            <div id="text">Текст который надо спрятать</div>
            <script>
                function task1(elem) {
                    elem.style.display = 'none'
                }
            </script>
        </div>
        <div id="task2">
            <h4>Задача 2 Спрятать себя</h4>
            <input type="button" value="Кнопка которую надо спрятать" id="button0" onclick="task2(button0)">
            <script>
                function task2(elem) {
                    elem.style.display = 'none'
                }
            </script>
        </div>
        <div id="task3">
            <h4>Задача 3</h4> при нажатии кнопки появился 1 и 2.
        </div>
    </div>


</body>

</html>