<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Методы RegExp и String
    </title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script defer src="../scripts.js"></script>
</head>

<body>
    <div class="contents">
        <h2><a href="#method">Методы RegExp и String</a></h2>
        <ul>
            <li><a href="#match">str.match(regexp)</a></li>
            <li><a href="#matchAll">str.matchAll(regexp)</a></li>
            <li><a href="#split">str.split(regexp|substr, limit)</a></li>
            <li><a href="#search">str.search(regexp)</a></li>
            <li><a href="#replace">str.replace(str|regexp, str|func)</a></li>
            <li><a href="#exec">regexp.exec(str)</a></li>
            <li><a href="#test">regexp.exec(str)</a></li>
        </ul>
    </div>
    <div class="topic" id="method">
        <h2><a href="https://learn.javascript.ru/regexp-methods">Методы RegExp и String</a></h2>
        <p>В этой главе мы рассмотрим все детали методов для работы с регулярными выражениями.</p>
    </div>
    <div class="topic" id="match">
        <h3>str.match(regexp)</h3>
        <p>Метод <code>str.match(regexp)</code> ищет совпадения с <code>regexp</code> в строке <code>str</code>. У него
            есть три режима работы:</p>
        <ol>
            <li>Если у регулярного выражения нет флага <code>g</code>, то он возвращает первое совпадение в виде массива
                со
                скобочными группами и свойствами <code>index</code> (позиция совпадения), <code>input</code> (строка
                поиска, равна <code>str</code>):
                <pre><code class="language-js">
let str = "I love JavaScript";

let result = str.match(/Java(Script)/);

alert( result[0] );     // JavaScript (всё совпадение)
alert( result[1] );     // Script (первые скобки)
alert( result.length ); // 2

// Дополнительная информация:
alert( result.index );  // 7 (позиция совпадения)
alert( result.input );  // I love JavaScript (исходная строка)                
            </code></pre>
            </li>
            <li>Если у регулярного выражения есть флаг <code>g</code>, то он возвращает массив всех совпадений, без
                скобочных групп и других деталей.
                <pre><code class="language-js">
let str = "I love JavaScript";

let result = str.match(/Java(Script)/g);

alert( result[0] ); // JavaScript
alert( result.length ); // 1                
            </code></pre>
            </li>
            <li>Если совпадений нет, то, вне зависимости от наличия флага <code>g</code>, возвращается
                <code>null</code>. Это очень важный нюанс. При отсутствии совпадений возвращается не пустой массив, а
                именно
                <code>null</code>. Если об этом забыть, можно легко допустить ошибку, например:
                <pre><code class="language-js">
let str = "I love JavaScript";

let result = str.match(/HTML/);

alert(result); // null
alert(result.length); // Ошибка: у null нет свойства length                
            </code></pre>
                <p>Если хочется, чтобы результатом всегда был массив, можно написать так:</p>
                <pre><code class="language-js">
let result = str.match(regexp) || [];                
            </code></pre>
            </li>
        </ol>
    </div>
    <div class="topic" id="matchAll">
        <h3>str.matchAll(regexp)</h3>
        <p>Метод <code>str.matchAll(regexp)</code> – «новый, улучшенный» вариант метода <code>str.match</code>, который
            используеться для поиска всех отличий и имеет различия от
            <code>match</code>:
        </p>
        <ol>
            <li>Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи
                <code>Array.from</code>.
            </li>
            <li>Каждое совпадение возвращается в виде массива со скобочными группами (как <code>str.match</code> без
                флага <code>g</code>).</li>
            <li>Если совпадений нет, то возвращается не <code>null</code>, а пустой перебираемый объект. </li>
        </ol>
        <p>Например:</p>
        <pre><code class="language-js startbutton" onclick="expl0()">
let str = '&lt;h1&gt;Hello, world!&lt;/h1&gt;';
let regexp = /<(.*?)>/g;

let matchAll = str.matchAll(regexp);

alert(matchAll); // [object RegExp String Iterator], не массив, а перебираемый объект

matchAll = Array.from(matchAll); // теперь массив
alert(matchAll); // Показывает все результаты. И далее:
let firstMatch = matchAll[0];
alert( firstMatch[0] );  // &lt;h1>
alert( firstMatch[1] );  // h1
alert( firstMatch.index );  // 0
alert( firstMatch.input );  // &lt;h1>Hello, world!&lt;/h1>            
        </code></pre>
        <script>
            function expl0(params) {
                let str = '<h1>Hello, world!</h1>';
                let regexp = /<(.*?)>/g;

                let matchAll = str.matchAll(regexp);
                alert(matchAll);
                matchAll = Array.from(matchAll);
                alert(matchAll);
                let firstMatch = matchAll[0];
                alert(firstMatch[0]);
                alert(firstMatch[1]);
                alert(firstMatch.index);
                alert(firstMatch.input);
            }
        </script>
    </div>
    <div class="topic" id="split">
        <h3>str.split(regexp|substr, limit)</h3>
        <p>
            Разбивает строку в массив по разделителю – регулярному выражению regexp или подстроке substr.
            Обычно мы используем метод <code>split</code> со строками, вот так:
        </p>
        <pre><code class="language-js startbutton" onclick="expl1()">
alert('12-34-56'.split('-')) // массив [12, 34, 56]
//Так же можно по регулярке:
alert('12, 34, 56'.split(/,\s*/)) // массив [12, 34, 56]            
        </code></pre>
        <script>
            function expl1() {
                alert('12-34-56'.split('-'))
                alert('12, 34, 56'.split(/,\s*/))
            }
        </script>
    </div>
    <div class="topic" id="search">
        <h3>str.search(regexp)</h3>
        <p>Метод <code>str.search(regexp)</code> возвращает позицию первого совпадения с regexp в строке str или -1,
            если совпадения нет. Однако <code>search</code> возвращает только позицию первого совпадения.</p>
        <p>Если нужны позиции всех сопадений, но используeтся <code>matchAll</code>.</p>
        <pre><code class="language-js">
let str = "Я люблю JavaScript!";

let regexp = /Java.+/;

alert( str.search(regexp) ); // 8                
            </code></pre>
    </div>
    <div class="topic" id="replace">
        <h3><a href="https://learn.javascript.ru/regexp-methods#str-replace-str-regexp-str-func">str.replace(str|regexp,
                str|func)</a></h3>
        <p>Далее вкратце пройдусь по методам. Смысла копипстить доку особо нет.</p>
        <p>Метод используется для поиска и замены, как понятно из названия можно использовать регекспы и функции. А так
            же можно
            использовать спецсимволы.</p>
    </div>
    <div class="topic" id="exec">
        <h3><a href="https://learn.javascript.ru/regexp-methods#regexp-exec-str">regexp.exec(str)</a></h3>
        <p>Метод <code>regexp.exec(str)</code> ищет совпадение с <code>regexp</code> в строке <code>str</code>. В
            отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.</p>
    </div>
    <div class="topic" id="test">
        <h3><a href="https://learn.javascript.ru/regexp-methods#regexp-test-str">regexp.test(str)</a></h3>
        <p>Метод <code>regexp.test(str)</code> ищет совпадение и возвращает <code>true/false</code>, в зависимости от
            того, находит ли он его.</p>
    </div>






</body>

</html>