<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Делегирование событий</title>
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body>
  <div class="contents">
    <h2><a href="#eventdelegation">Делегирование событий</a></h2>
    <ul>
      <li><a href="#apply">Применение делегирования: действия в разметке</a></li>
      <li><a href="#design">Приём проектирования «поведение»</a></li>
      <li><a href="#total">Итого</a></li>
      <li><a href="#tasks">Задачи</a></li>
    </ul>
  </div>

  <div class="topic" id="eventdelegation">
    <h2><a href="https://learn.javascript.ru/event-delegation">Делегирование событий</a></h2>
    <p>Высплытие позволяет создавать в браузере делегирование событий. Смысл его заключается в том, чтобы назначать
      вышестоящим элементам, например <code>document</code> события низлежайших уровней и перехватывать их при
      всплытии проверяя где произошло событие при помощи event.target.</p>
    <p>Далее приводится пример подкрашивания ячеек в таблице на основе:
    <pre>
    <code class="language-js">
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
let selectedTd;
function highlight(td) {
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // подсветить новый td
}        
    </code>
</pre>
    Очередной кусок мутного кода, особенно изначально, но идея я думаю понятна.
    </p>
  </div>
  <div class="topic" id="apply">
    <h3>Применение делегирования: действия в разметке</h3>
    <div id="menu">
      <button data-action="save">Сохранить</button>
      <button data-action="load">Загрузить</button>
      <button data-action="search">Поиск</button>
    </div>

    <script>
      class Menu {
        constructor(elem) {
          elem.onclick = this.onClick.bind(this); // (*)
        }

        save() {
          alert('сохраняю');
        }

        load() {
          alert('загружаю');
        }

        search() {
          alert('ищу');
        }

        onClick(event) {
          let action = event.target.dataset.action;
          if (action) {
            this[action]();
          }
        }
      }

      new Menu(menu);
    </script>
    <p>Можно повесить на каждуй кнопку свой отдельный обработчик, а можно сделать по иному:
    <pre><code class="language-js">
&lt;div id="menu">
  &lt;button data-action="save">Сохранить</button>
  &lt;button data-action="load">Загрузить</button>
  &lt;button data-action="search">Поиск</button>
&lt;/div>

&lt;script>
  class Menu {
    constructor(elem) {
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    }
  }

  new Menu(menu);
  &lt;/script>    
</code></pre>
    Обратите внимание, что метод this.onClick в строке, отмеченной звёздочкой (*), привязывается к контексту текущего
    объекта this. Это важно, т.к. иначе this внутри него будет ссылаться на DOM-элемент (elem), а не на объект Menu, и
    this[action] будет не тем, что нам нужно.
    </p>
  </div>
  <div class="topic" id="design">
    <h3>Приём проектирования «поведение»</h3>
    <p>
      Приём проектирования «поведение» состоит из двух частей:
    <ol>
      <li>Элементу ставится пользовательский атрибут, описывающий его поведение.</li>
      <li>При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если
        элемент имеет нужный атрибут, производит соответствующее действие.</li>
    </ol>
    </p>
    <h4>Поведение: «Счётчик»</h4>
    Счётчик: <input type="button" value="1" data-counter>
    Ещё счётчик: <input type="button" value="2" data-counter>

    <script>
      document.addEventListener('click', function (event) {

        if (event.target.dataset.counter != undefined) { // если есть атрибут...
          event.target.value++;
        }

      });
    </script>
    <pre>
    <code class="language-js">
Счётчик: &lt;input type="button" value="1" data-counter>
Ещё счётчик: &lt;input type="button" value="2" data-counter>

&lt;script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // если есть атрибут...
      event.target.value++;
    }

  });
&lt;/script>        
    </code>
</pre>
    <p>В этом простом примере отражается вся суть паттерна проектирования: поведение вешается на однотипные элементы. В
      данном случае путем добавления свойства data-counter</p>
    <blockquote>
      <h4>Всегда используйте метод addEventListener для обработчиков на уровне документа
      </h4>Чтобы разные обработчики не перезаписывали друг друга.
    </blockquote>
    <h4>Поведение: «Переключатель» (Toggler)</h4>
    <p>Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом data-toggle-id будет
      скрываться/показываться элемент с заданным id:</p>
    <button data-toggle-id="subscribe-mail">
      Показать форму подписки
    </button>

    <form id="subscribe-mail" hidden>
      Ваша почта: <input type="email">
    </form>

    <script>
      document.addEventListener('click', function (event) {
        let id = event.target.dataset.toggleId;
        if (!id) return;

        let elem = document.getElementById(id);

        elem.hidden = !elem.hidden;
      });
    </script>
    <pre>
    <code class="language-js">
&lt;button data-toggle-id="subscribe-mail">
  Показать форму подписки
&lt;/button>

&lt;form id="subscribe-mail" hidden>
  Ваша почта: &lt;input type="email">
&lt;/form>

&lt;script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
&lt;/script>        
    </code>
</pre>
  </div>
  <div class="topic" id="total">
    <h3>Итого</h3>
    <p>Алгоритм делегирования событий:
    <ol>
      <li>Вешаем обработчик на контейнер.</li>
      <li>В обработчике проверяем исходный элемент event.target.</li>
      <li>Если событие произошло внутри нужного нам элемента, то обрабатываем его. </li>
    </ol>
    Используем для:
    <ul>
      <li>Упрощает процесс инициализации и экономит память, одному обработчику множество элементов.</li>
      <li>При добавлении или удалении элементов не нужно лезь в логику javascript.</li>
      <li>Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
      </li>

    </ul>
    Делегирование имеет свои ограничения:
    <ul>
      <li>Некоторые события не всплывают, так же низкоуровневые обработчики не должны вызывать event.stopPropagation().
      </li>
      <li>Делегирование вызывает дополнительную нагрузку, но как правило она незначительна.</li>
    </ul>
    </p>
  </div>
  <div class="topic" id="tasks">
    <h3>Задачи</h3>
    <div id="task1">
      <h4>Задача 1</h4>
      <div id="container">
        <style>
          h3 {
            margin: 0;
            padding-bottom: .3em;
            padding-right: 20px;
            font-size: 1.1em;
          }

          p {
            margin: 0;
            padding: 0 0 .5em;
          }

          .pane {
            background: #edf5e1;
            padding: 10px 20px 10px;
            border-top: solid 2px #c4df9b;
            position: relative;
          }

          .remove-button {
            position: absolute;
            font-size: 110%;
            top: 0;
            color: darkred;
            right: 10px;
            display: block;
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            cursor: pointer;
          }
        </style>
        <div class="pane">
          <h3>Лошадь</h3>
          <p>Домашняя лошадь - животное семейства непарнокопытных, одомашненный и единственный сохранившийся подвид
            дикой лошади, вымершей в дикой природе, за исключением небольшой популяции лошади Пржевальского.</p>
          <button class="remove-button">[x]</button>
        </div>
        <div class="pane">
          <h3>Осёл</h3>
          <p>Домашний осёл или ишак — одомашненный подвид дикого осла, сыгравший важную историческую роль в развитии
            хозяйства и культуры человека. Все одомашненные ослы относятся к африканским ослам.</p>
          <button class="remove-button">[x]</button>
        </div>
        <div class="pane">
          <h3>Кошка</h3>
          <p>Кошка, или домашняя кошка (лат. Félis silvéstris cátus), — домашнее животное, одно из наиболее популярных
            (наряду с собакой) "животных-компаньонов". С точки зрения научной систематики, домашняя кошка —
            млекопитающее семейства кошачьих отряда хищных. Ранее домашнюю кошку нередко рассматривали как отдельный
            биологический вид.
          </p>
          <button class="remove-button">[x]</button>
        </div>
      </div>
      <script>
        function removeElement(event) {
          if (event.target.className == 'remove-button') event.target.parentNode.style.display = 'none'
        }
        document.addEventListener("click", removeElement)
      </script>
    </div>
    <div id="task2">
      <h4>Задача 2</h4>

      <ul class="tree" id="tree" style="cursor: pointer;">
        <li>Животные
          <ul>
            <li>Млекопитающие
              <ul>
                <li>Коровы</li>
                <li>Ослы</li>
                <li>Собаки</li>
                <li>Тигры</li>
              </ul>
            </li>
            <li>Другие
              <ul>
                <li>Змеи</li>
                <li>Птицы</li>
                <li>Ящерицы</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Рыбы
          <ul>
            <li>Аквариумные
              <ul>
                <li>Гуппи</li>
                <li>Скалярии</li>
              </ul>
            </li>
            <li>Морские
              <ul>
                <li>Морская форель</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <script>
        function task2(event) {
          if (event.target.tagName == 'LI') {
            for (let child of event.target.childNodes) child.hidden = !child.hidden
          }
        }
        tree.addEventListener('click', task2)
      </script>
    </div>
    <div id="task3">
      <h4>Задача 3</h4>
      <style>
        table {
          border-collapse: collapse;
        }

        th,
        td {
          border: 1px solid black;
          padding: 4px;
        }

        th {
          cursor: pointer;
        }

        th:hover {
          background: yellow;
        }
      </style>
      <table id="grid">
        <thead>
          <tr>
            <th data-type="number">Возраст</th>
            <th data-type="string">Имя</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>5</td>
            <td>Вася</td>
          </tr>
          <tr>
            <td>2</td>
            <td>Петя</td>
          </tr>
          <tr>
            <td>12</td>
            <td>Женя</td>
          </tr>
          <tr>
            <td>9</td>
            <td>Маша</td>
          </tr>
          <tr>
            <td>1</td>
            <td>Илья</td>
          </tr>
        </tbody>
      </table>

      <script>
        function task3(event) {
          let trs = grid.querySelector('tbody').querySelectorAll('tr')
          let tbody = grid.querySelector('tbody')
          if (event.target.dataset.type == 'number') {
            tbody.innerHTML = ''
            tbody.append(...Array.from(trs).sort((a, b) => (a.cells[0].innerHTML - b.cells[0].innerHTML)))
          }
          if (event.target.dataset.type == 'string') {
            tbody.append(...Array.from(trs).sort((a, b) => ((a.cells[1].innerHTML).localeCompare(b.cells[1].innerHTML))))
          }
        }
        grid.addEventListener('click', task3)
      </script>

    </div>

    <div id="task4">
      <h4><a href="https://learn.javascript.ru/event-delegation#povedenie-podskazka">Задача 4</a></h4>
      <style>


        .tooltip {
          /* немного стилизуем подсказку, можете использовать свои стили вместо этих */
          position: fixed;
          padding: 10px 20px;
          border: 1px solid #b3c9ce;
          border-radius: 4px;
          text-align: center;
          font: italic 14px/1.3 sans-serif;
          color: #333;
          background: #fff;
          box-shadow: 3px 3px 3px rgba(0, 0, 0, .3);
        }
      </style>
      

     

        <p>ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя</p>
        <p>ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя ЛяЛяЛя</p>

        <button data-tooltip="эта подсказка должна быть длиннее, чем элемент">Короткая кнопка</button>
        <button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>

        <p>Прокрутите страницу, чтобы кнопки оказались у верхнего края, а затем проверьте правильно ли выводятся
          подсказки.</p>


        <script>
          let paragraph = document.createElement('p')
          paragraph.className = 'tooltip'
          function showTooltip(event) {
            if (event.target.dataset.tooltip) {
              paragraph.innerHTML = event.target.dataset.tooltip
              document.body.append(paragraph)
              paragraph.style.display = ''
              paragraph.style.position = 'absolute';
              /* не нужный кусок кода есть все в css
              paragraph.style.background = 'white'
              paragraph.style.border = '1px solid black'
              paragraph.style.borderRadius = '5px'
              paragraph.style.paddingLeft = '5px'
              paragraph.style.paddingRight = '5px'
              paragraph.style.boxShadow = '4px 4px 8px rgba(0, 0, 0, 0.3)'; */
              paragraph.style.top = event.target.offsetTop - paragraph.offsetHeight - 2 + 'px'
              paragraph.style.left = event.target.offsetLeft + 'px'
            }
          }
          function removeToolTip(event) {
            if (event.target.dataset.tooltip) paragraph.style.display = 'none';
          }
          document.addEventListener('mouseover', showTooltip)
          document.addEventListener('mouseout', removeToolTip)
        </script>
        <div id="technical" style="width: 1000; height: 2000;">
          В целом задача решена. Дипсик предложил использовать авторский css и я понял что он реально прав, так же удаление у него через:
          <pre>
              <code class="language-js">
let currentTooltip = null;

function showTooltip(event) {
    const tooltipText = event.target.dataset.tooltip;
    if (!tooltipText) return;
    
    // Удаляем предыдущую подсказку
    if (currentTooltip) {
        currentTooltip.remove();
    }
    
    // Создаем новую подсказку
    currentTooltip = document.createElement('div');
    currentTooltip.className = 'tooltip'; // Используем CSS из стилей
    currentTooltip.textContent = tooltipText; // Безопасно, не HTML
    
    document.body.append(currentTooltip);
    
    // Позиционирование относительно viewport (с учетом прокрутки)
    const rect = event.target.getBoundingClientRect();
    currentTooltip.style.top = (rect.top - currentTooltip.offsetHeight - 5) + 'px';
    currentTooltip.style.left = rect.left + 'px';
}

function removeToolTip(event) {
    if (event.target.dataset.tooltip && currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
    }
}

// Вешаем обработчики
document.addEventListener('mouseover', showTooltip);
document.addEventListener('mouseout', removeToolTip);                  
              </code>
          </pre>
          Его версия кода. Одно из замечаний быстрое мигание, как по мне не очень существенно.
          <br>Моя версия
          <pre>
              <code class="language-js">
          let paragraph = document.createElement('p')
          paragraph.className = 'tooltip'
          function showTooltip(event) {
            if (event.target.dataset.tooltip) {
              paragraph.innerHTML = event.target.dataset.tooltip
              document.body.append(paragraph)
              paragraph.style.display = ''
              paragraph.style.position = 'absolute';
              /* не нужный кусок кода есть все в css
              paragraph.style.background = 'white'
              paragraph.style.border = '1px solid black'
              paragraph.style.borderRadius = '5px'
              paragraph.style.paddingLeft = '5px'
              paragraph.style.paddingRight = '5px'
              paragraph.style.boxShadow = '4px 4px 8px rgba(0, 0, 0, 0.3)'; */
              paragraph.style.top = event.target.offsetTop - paragraph.offsetHeight - 2 + 'px'
              paragraph.style.left = event.target.offsetLeft + 'px'
            }
          }
          function removeToolTip(event) {
            if (event.target.dataset.tooltip) paragraph.style.display = 'none';
          }
          document.addEventListener('mouseover', showTooltip)
          document.addEventListener('mouseout', removeToolTip)                  
              </code>
          </pre>
          Не решено: проверка на видимость подскаки и перенос её вниз. В некотором смысле мне лень. Оставляю до будущих проработок.
        </div>
    </div>
  </div>









</body>

</html>